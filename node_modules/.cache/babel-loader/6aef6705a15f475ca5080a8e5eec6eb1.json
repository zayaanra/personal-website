{"ast":null,"code":"// @ts-ignore JS file\nimport interpolateNode from '../reanimated1/derived/interpolate';\nexport var Extrapolation;\n\n(function (Extrapolation) {\n  Extrapolation[\"IDENTITY\"] = \"identity\";\n  Extrapolation[\"CLAMP\"] = \"clamp\";\n  Extrapolation[\"EXTEND\"] = \"extend\";\n})(Extrapolation || (Extrapolation = {}));\n\nfunction isNode(x) {\n  'worklet';\n\n  return x.__nodeId !== undefined;\n}\n\nfunction getVal(type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {\n  'worklet';\n\n  switch (type) {\n    case Extrapolation.IDENTITY:\n      return x;\n\n    case Extrapolation.CLAMP:\n      if (coef * val < coef * leftEdgeOutput) {\n        return leftEdgeOutput;\n      }\n\n      return rightEdgeOutput;\n\n    case Extrapolation.EXTEND:\n    default:\n      return val;\n  }\n}\n\nfunction isExtrapolate(value) {\n  'worklet';\n\n  return value === Extrapolation.EXTEND || value === Extrapolation.CLAMP || value === Extrapolation.IDENTITY;\n} // validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\n\n\nfunction validateType(type) {\n  'worklet'; // initialize extrapolationConfig with default extrapolation\n\n  const extrapolationConfig = {\n    extrapolateLeft: Extrapolation.EXTEND,\n    extrapolateRight: Extrapolation.EXTEND\n  };\n\n  if (!type) {\n    return extrapolationConfig;\n  }\n\n  if (typeof type === 'string') {\n    if (!isExtrapolate(type)) {\n      throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`);\n    }\n\n    extrapolationConfig.extrapolateLeft = type;\n    extrapolationConfig.extrapolateRight = type;\n    return extrapolationConfig;\n  } // otherwise type is extrapolation config object\n\n\n  if (type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft) || type.extrapolateRight && !isExtrapolate(type.extrapolateRight)) {\n    throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`);\n  }\n\n  Object.assign(extrapolationConfig, type);\n  return extrapolationConfig;\n}\n\nfunction internalInterpolate(x, narrowedInput, extrapolationConfig) {\n  'worklet';\n\n  const {\n    leftEdgeInput,\n    rightEdgeInput,\n    leftEdgeOutput,\n    rightEdgeOutput\n  } = narrowedInput;\n  if (rightEdgeInput - leftEdgeInput === 0) return leftEdgeOutput;\n  const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n  const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n  const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n\n  if (coef * val < coef * leftEdgeOutput) {\n    return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n  } else if (coef * val > coef * rightEdgeOutput) {\n    return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n  }\n\n  return val;\n} // TODO: support default values in worklets:\n// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)\n\n\nexport function interpolate(x, input, output, type) {\n  'worklet';\n\n  if (input.length < 2 || output.length < 2) {\n    throw Error('Interpolation input and output should contain at least two values.');\n  }\n\n  const extrapolationConfig = validateType(type);\n\n  if (isNode(x)) {\n    console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n    return interpolateNode(x, {\n      inputRange: input,\n      outputRange: output,\n      extrapolateLeft: extrapolationConfig.extrapolateLeft,\n      extrapolateRight: extrapolationConfig.extrapolateRight\n    });\n  }\n\n  const length = input.length;\n  const narrowedInput = {\n    leftEdgeInput: input[0],\n    rightEdgeInput: input[1],\n    leftEdgeOutput: output[0],\n    rightEdgeOutput: output[1]\n  };\n\n  if (length > 2) {\n    if (x > input[length - 1]) {\n      narrowedInput.leftEdgeInput = input[length - 2];\n      narrowedInput.rightEdgeInput = input[length - 1];\n      narrowedInput.leftEdgeOutput = output[length - 2];\n      narrowedInput.rightEdgeOutput = output[length - 1];\n    } else {\n      for (let i = 1; i < length; ++i) {\n        if (x <= input[i]) {\n          narrowedInput.leftEdgeInput = input[i - 1];\n          narrowedInput.rightEdgeInput = input[i];\n          narrowedInput.leftEdgeOutput = output[i - 1];\n          narrowedInput.rightEdgeOutput = output[i];\n          break;\n        }\n      }\n    }\n  }\n\n  return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/react-native-reanimated/lib/reanimated2/interpolation.js"],"names":["interpolateNode","Extrapolation","isNode","x","__nodeId","undefined","getVal","type","coef","val","leftEdgeOutput","rightEdgeOutput","IDENTITY","CLAMP","EXTEND","isExtrapolate","value","validateType","extrapolationConfig","extrapolateLeft","extrapolateRight","Error","Object","assign","internalInterpolate","narrowedInput","leftEdgeInput","rightEdgeInput","progress","interpolate","input","output","length","console","warn","inputRange","outputRange","i"],"mappings":"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","sourcesContent":["// @ts-ignore JS file\nimport interpolateNode from '../reanimated1/derived/interpolate';\nexport var Extrapolation;\n(function (Extrapolation) {\n    Extrapolation[\"IDENTITY\"] = \"identity\";\n    Extrapolation[\"CLAMP\"] = \"clamp\";\n    Extrapolation[\"EXTEND\"] = \"extend\";\n})(Extrapolation || (Extrapolation = {}));\nfunction isNode(x) {\n    'worklet';\n    return x.__nodeId !== undefined;\n}\nfunction getVal(type, coef, val, leftEdgeOutput, rightEdgeOutput, x) {\n    'worklet';\n    switch (type) {\n        case Extrapolation.IDENTITY:\n            return x;\n        case Extrapolation.CLAMP:\n            if (coef * val < coef * leftEdgeOutput) {\n                return leftEdgeOutput;\n            }\n            return rightEdgeOutput;\n        case Extrapolation.EXTEND:\n        default:\n            return val;\n    }\n}\nfunction isExtrapolate(value) {\n    'worklet';\n    return (value === Extrapolation.EXTEND ||\n        value === Extrapolation.CLAMP ||\n        value === Extrapolation.IDENTITY);\n}\n// validates extrapolations type\n// if type is correct, converts it to ExtrapolationConfig\nfunction validateType(type) {\n    'worklet';\n    // initialize extrapolationConfig with default extrapolation\n    const extrapolationConfig = {\n        extrapolateLeft: Extrapolation.EXTEND,\n        extrapolateRight: Extrapolation.EXTEND,\n    };\n    if (!type) {\n        return extrapolationConfig;\n    }\n    if (typeof type === 'string') {\n        if (!isExtrapolate(type)) {\n            throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n        interpolate(value, [inputRange], [outputRange], \"clamp\")`);\n        }\n        extrapolationConfig.extrapolateLeft = type;\n        extrapolationConfig.extrapolateRight = type;\n        return extrapolationConfig;\n    }\n    // otherwise type is extrapolation config object\n    if ((type.extrapolateLeft && !isExtrapolate(type.extrapolateLeft)) ||\n        (type.extrapolateRight && !isExtrapolate(type.extrapolateRight))) {\n        throw new Error(`Reanimated: not supported value for \"interpolate\" \\nSupported values: [\"extend\", \"clamp\", \"identity\", Extrapolatation.CLAMP, Extrapolatation.EXTEND, Extrapolatation.IDENTITY]\\n Valid example:\n      interpolate(value, [inputRange], [outputRange], {\n        extrapolateLeft: Extrapolation.CLAMP,\n        extrapolateRight: Extrapolation.IDENTITY\n      }})`);\n    }\n    Object.assign(extrapolationConfig, type);\n    return extrapolationConfig;\n}\nfunction internalInterpolate(x, narrowedInput, extrapolationConfig) {\n    'worklet';\n    const { leftEdgeInput, rightEdgeInput, leftEdgeOutput, rightEdgeOutput, } = narrowedInput;\n    if (rightEdgeInput - leftEdgeInput === 0)\n        return leftEdgeOutput;\n    const progress = (x - leftEdgeInput) / (rightEdgeInput - leftEdgeInput);\n    const val = leftEdgeOutput + progress * (rightEdgeOutput - leftEdgeOutput);\n    const coef = rightEdgeOutput >= leftEdgeOutput ? 1 : -1;\n    if (coef * val < coef * leftEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateLeft, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    else if (coef * val > coef * rightEdgeOutput) {\n        return getVal(extrapolationConfig.extrapolateRight, coef, val, leftEdgeOutput, rightEdgeOutput, x);\n    }\n    return val;\n}\n// TODO: support default values in worklets:\n// e.g. function interpolate(x, input, output, type = Extrapolatation.CLAMP)\nexport function interpolate(x, input, output, type) {\n    'worklet';\n    if (input.length < 2 || output.length < 2) {\n        throw Error('Interpolation input and output should contain at least two values.');\n    }\n    const extrapolationConfig = validateType(type);\n    if (isNode(x)) {\n        console.warn(`interpolate() was renamed to interpolateNode() in Reanimated 2. Please use interpolateNode() instead`);\n        return interpolateNode(x, {\n            inputRange: input,\n            outputRange: output,\n            extrapolateLeft: extrapolationConfig.extrapolateLeft,\n            extrapolateRight: extrapolationConfig.extrapolateRight,\n        });\n    }\n    const length = input.length;\n    const narrowedInput = {\n        leftEdgeInput: input[0],\n        rightEdgeInput: input[1],\n        leftEdgeOutput: output[0],\n        rightEdgeOutput: output[1],\n    };\n    if (length > 2) {\n        if (x > input[length - 1]) {\n            narrowedInput.leftEdgeInput = input[length - 2];\n            narrowedInput.rightEdgeInput = input[length - 1];\n            narrowedInput.leftEdgeOutput = output[length - 2];\n            narrowedInput.rightEdgeOutput = output[length - 1];\n        }\n        else {\n            for (let i = 1; i < length; ++i) {\n                if (x <= input[i]) {\n                    narrowedInput.leftEdgeInput = input[i - 1];\n                    narrowedInput.rightEdgeInput = input[i];\n                    narrowedInput.leftEdgeOutput = output[i - 1];\n                    narrowedInput.rightEdgeOutput = output[i];\n                    break;\n                }\n            }\n        }\n    }\n    return internalInterpolate(x, narrowedInput, extrapolationConfig);\n}\n"]},"metadata":{},"sourceType":"module"}