{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isCallExpression,\n  isClassDeclaration,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, _ref) {\n  let {\n    expressionStatement = false,\n    arrowBody = false,\n    exportDefault = false,\n    forHead = false,\n    forInHead = false,\n    forOfHead = false\n  } = _ref;\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/generator/lib/node/parentheses.js"],"names":["Object","defineProperty","exports","value","ArrowFunctionExpression","AssignmentExpression","Binary","BinaryExpression","ClassExpression","ConditionalExpression","DoExpression","FunctionExpression","FunctionTypeAnnotation","Identifier","LogicalExpression","NullableTypeAnnotation","ObjectExpression","OptionalIndexedAccessType","OptionalCallExpression","OptionalMemberExpression","SequenceExpression","TSAsExpression","TSInferType","TSTypeAssertion","TSIntersectionType","TSUnionType","UnaryLike","IntersectionTypeAnnotation","UnionTypeAnnotation","UpdateExpression","AwaitExpression","YieldExpression","_t","require","isArrayTypeAnnotation","isArrowFunctionExpression","isAssignmentExpression","isAwaitExpression","isBinary","isBinaryExpression","isCallExpression","isClassDeclaration","isClassExpression","isConditional","isConditionalExpression","isExportDeclaration","isExportDefaultDeclaration","isExpressionStatement","isFor","isForInStatement","isForOfStatement","isForStatement","isIfStatement","isIndexedAccessType","isIntersectionTypeAnnotation","isLogicalExpression","isMemberExpression","isNewExpression","isNullableTypeAnnotation","isObjectPattern","isOptionalCallExpression","isOptionalMemberExpression","isReturnStatement","isSequenceExpression","isSwitchStatement","isTSArrayType","isTSAsExpression","isTSIntersectionType","isTSNonNullExpression","isTSOptionalType","isTSRestType","isTSTypeAssertion","isTSUnionType","isTaggedTemplateExpression","isThrowStatement","isTypeAnnotation","isUnaryLike","isUnionTypeAnnotation","isVariableDeclarator","isWhileStatement","isYieldExpression","PRECEDENCE","in","instanceof","isClassExtendsClause","node","parent","superClass","hasPostfixPart","object","callee","tag","printStack","length","isFirstInContext","expressionStatement","arrowBody","async","operator","left","parentOp","parentPos","nodeOp","nodePos","right","objectType","test","discriminant","expression","exportDefault","name","isFollowedByBracket","computed","optional","forHead","forInHead","forOfHead","i","declaration","body","init","expressions"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrowFunctionExpression = ArrowFunctionExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.Binary = Binary;\nexports.BinaryExpression = BinaryExpression;\nexports.ClassExpression = ClassExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.DoExpression = DoExpression;\nexports.FunctionExpression = FunctionExpression;\nexports.FunctionTypeAnnotation = FunctionTypeAnnotation;\nexports.Identifier = Identifier;\nexports.LogicalExpression = LogicalExpression;\nexports.NullableTypeAnnotation = NullableTypeAnnotation;\nexports.ObjectExpression = ObjectExpression;\nexports.OptionalIndexedAccessType = OptionalIndexedAccessType;\nexports.OptionalCallExpression = exports.OptionalMemberExpression = OptionalMemberExpression;\nexports.SequenceExpression = SequenceExpression;\nexports.TSAsExpression = TSAsExpression;\nexports.TSInferType = TSInferType;\nexports.TSTypeAssertion = TSTypeAssertion;\nexports.TSIntersectionType = exports.TSUnionType = TSUnionType;\nexports.UnaryLike = UnaryLike;\nexports.IntersectionTypeAnnotation = exports.UnionTypeAnnotation = UnionTypeAnnotation;\nexports.UpdateExpression = UpdateExpression;\nexports.AwaitExpression = exports.YieldExpression = YieldExpression;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isArrayTypeAnnotation,\n  isArrowFunctionExpression,\n  isAssignmentExpression,\n  isAwaitExpression,\n  isBinary,\n  isBinaryExpression,\n  isCallExpression,\n  isClassDeclaration,\n  isClassExpression,\n  isConditional,\n  isConditionalExpression,\n  isExportDeclaration,\n  isExportDefaultDeclaration,\n  isExpressionStatement,\n  isFor,\n  isForInStatement,\n  isForOfStatement,\n  isForStatement,\n  isIfStatement,\n  isIndexedAccessType,\n  isIntersectionTypeAnnotation,\n  isLogicalExpression,\n  isMemberExpression,\n  isNewExpression,\n  isNullableTypeAnnotation,\n  isObjectPattern,\n  isOptionalCallExpression,\n  isOptionalMemberExpression,\n  isReturnStatement,\n  isSequenceExpression,\n  isSwitchStatement,\n  isTSArrayType,\n  isTSAsExpression,\n  isTSIntersectionType,\n  isTSNonNullExpression,\n  isTSOptionalType,\n  isTSRestType,\n  isTSTypeAssertion,\n  isTSUnionType,\n  isTaggedTemplateExpression,\n  isThrowStatement,\n  isTypeAnnotation,\n  isUnaryLike,\n  isUnionTypeAnnotation,\n  isVariableDeclarator,\n  isWhileStatement,\n  isYieldExpression\n} = _t;\nconst PRECEDENCE = {\n  \"||\": 0,\n  \"??\": 0,\n  \"&&\": 1,\n  \"|\": 2,\n  \"^\": 3,\n  \"&\": 4,\n  \"==\": 5,\n  \"===\": 5,\n  \"!=\": 5,\n  \"!==\": 5,\n  \"<\": 6,\n  \">\": 6,\n  \"<=\": 6,\n  \">=\": 6,\n  in: 6,\n  instanceof: 6,\n  \">>\": 7,\n  \"<<\": 7,\n  \">>>\": 7,\n  \"+\": 8,\n  \"-\": 8,\n  \"*\": 9,\n  \"/\": 9,\n  \"%\": 9,\n  \"**\": 10\n};\n\nconst isClassExtendsClause = (node, parent) => (isClassDeclaration(parent) || isClassExpression(parent)) && parent.superClass === node;\n\nconst hasPostfixPart = (node, parent) => (isMemberExpression(parent) || isOptionalMemberExpression(parent)) && parent.object === node || (isCallExpression(parent) || isOptionalCallExpression(parent) || isNewExpression(parent)) && parent.callee === node || isTaggedTemplateExpression(parent) && parent.tag === node || isTSNonNullExpression(parent);\n\nfunction NullableTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent);\n}\n\nfunction FunctionTypeAnnotation(node, parent, printStack) {\n  return isUnionTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isArrayTypeAnnotation(parent) || isTypeAnnotation(parent) && isArrowFunctionExpression(printStack[printStack.length - 3]);\n}\n\nfunction UpdateExpression(node, parent) {\n  return hasPostfixPart(node, parent) || isClassExtendsClause(node, parent);\n}\n\nfunction ObjectExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    arrowBody: true\n  });\n}\n\nfunction DoExpression(node, parent, printStack) {\n  return !node.async && isFirstInContext(printStack, {\n    expressionStatement: true\n  });\n}\n\nfunction Binary(node, parent) {\n  if (node.operator === \"**\" && isBinaryExpression(parent, {\n    operator: \"**\"\n  })) {\n    return parent.left === node;\n  }\n\n  if (isClassExtendsClause(node, parent)) {\n    return true;\n  }\n\n  if (hasPostfixPart(node, parent) || isUnaryLike(parent) || isAwaitExpression(parent)) {\n    return true;\n  }\n\n  if (isBinary(parent)) {\n    const parentOp = parent.operator;\n    const parentPos = PRECEDENCE[parentOp];\n    const nodeOp = node.operator;\n    const nodePos = PRECEDENCE[nodeOp];\n\n    if (parentPos === nodePos && parent.right === node && !isLogicalExpression(parent) || parentPos > nodePos) {\n      return true;\n    }\n  }\n}\n\nfunction UnionTypeAnnotation(node, parent) {\n  return isArrayTypeAnnotation(parent) || isNullableTypeAnnotation(parent) || isIntersectionTypeAnnotation(parent) || isUnionTypeAnnotation(parent);\n}\n\nfunction OptionalIndexedAccessType(node, parent) {\n  return isIndexedAccessType(parent, {\n    objectType: node\n  });\n}\n\nfunction TSAsExpression() {\n  return true;\n}\n\nfunction TSTypeAssertion() {\n  return true;\n}\n\nfunction TSUnionType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent) || isTSIntersectionType(parent) || isTSUnionType(parent) || isTSRestType(parent);\n}\n\nfunction TSInferType(node, parent) {\n  return isTSArrayType(parent) || isTSOptionalType(parent);\n}\n\nfunction BinaryExpression(node, parent) {\n  return node.operator === \"in\" && (isVariableDeclarator(parent) || isFor(parent));\n}\n\nfunction SequenceExpression(node, parent) {\n  if (isForStatement(parent) || isThrowStatement(parent) || isReturnStatement(parent) || isIfStatement(parent) && parent.test === node || isWhileStatement(parent) && parent.test === node || isForInStatement(parent) && parent.right === node || isSwitchStatement(parent) && parent.discriminant === node || isExpressionStatement(parent) && parent.expression === node) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction YieldExpression(node, parent) {\n  return isBinary(parent) || isUnaryLike(parent) || hasPostfixPart(node, parent) || isAwaitExpression(parent) && isYieldExpression(node) || isConditionalExpression(parent) && node === parent.test || isClassExtendsClause(node, parent);\n}\n\nfunction ClassExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction UnaryLike(node, parent) {\n  return hasPostfixPart(node, parent) || isBinaryExpression(parent, {\n    operator: \"**\",\n    left: node\n  }) || isClassExtendsClause(node, parent);\n}\n\nfunction FunctionExpression(node, parent, printStack) {\n  return isFirstInContext(printStack, {\n    expressionStatement: true,\n    exportDefault: true\n  });\n}\n\nfunction ArrowFunctionExpression(node, parent) {\n  return isExportDeclaration(parent) || ConditionalExpression(node, parent);\n}\n\nfunction ConditionalExpression(node, parent) {\n  if (isUnaryLike(parent) || isBinary(parent) || isConditionalExpression(parent, {\n    test: node\n  }) || isAwaitExpression(parent) || isTSTypeAssertion(parent) || isTSAsExpression(parent)) {\n    return true;\n  }\n\n  return UnaryLike(node, parent);\n}\n\nfunction OptionalMemberExpression(node, parent) {\n  return isCallExpression(parent, {\n    callee: node\n  }) || isMemberExpression(parent, {\n    object: node\n  });\n}\n\nfunction AssignmentExpression(node, parent) {\n  if (isObjectPattern(node.left)) {\n    return true;\n  } else {\n    return ConditionalExpression(node, parent);\n  }\n}\n\nfunction LogicalExpression(node, parent) {\n  switch (node.operator) {\n    case \"||\":\n      if (!isLogicalExpression(parent)) return false;\n      return parent.operator === \"??\" || parent.operator === \"&&\";\n\n    case \"&&\":\n      return isLogicalExpression(parent, {\n        operator: \"??\"\n      });\n\n    case \"??\":\n      return isLogicalExpression(parent) && parent.operator !== \"??\";\n  }\n}\n\nfunction Identifier(node, parent, printStack) {\n  if (node.name === \"let\") {\n    const isFollowedByBracket = isMemberExpression(parent, {\n      object: node,\n      computed: true\n    }) || isOptionalMemberExpression(parent, {\n      object: node,\n      computed: true,\n      optional: false\n    });\n    return isFirstInContext(printStack, {\n      expressionStatement: isFollowedByBracket,\n      forHead: isFollowedByBracket,\n      forInHead: isFollowedByBracket,\n      forOfHead: true\n    });\n  }\n\n  return node.name === \"async\" && isForOfStatement(parent) && node === parent.left;\n}\n\nfunction isFirstInContext(printStack, {\n  expressionStatement = false,\n  arrowBody = false,\n  exportDefault = false,\n  forHead = false,\n  forInHead = false,\n  forOfHead = false\n}) {\n  let i = printStack.length - 1;\n  let node = printStack[i];\n  i--;\n  let parent = printStack[i];\n\n  while (i >= 0) {\n    if (expressionStatement && isExpressionStatement(parent, {\n      expression: node\n    }) || exportDefault && isExportDefaultDeclaration(parent, {\n      declaration: node\n    }) || arrowBody && isArrowFunctionExpression(parent, {\n      body: node\n    }) || forHead && isForStatement(parent, {\n      init: node\n    }) || forInHead && isForInStatement(parent, {\n      left: node\n    }) || forOfHead && isForOfStatement(parent, {\n      left: node\n    })) {\n      return true;\n    }\n\n    if (hasPostfixPart(node, parent) && !isNewExpression(parent) || isSequenceExpression(parent) && parent.expressions[0] === node || isConditional(parent, {\n      test: node\n    }) || isBinary(parent, {\n      left: node\n    }) || isAssignmentExpression(parent, {\n      left: node\n    })) {\n      node = parent;\n      i--;\n      parent = printStack[i];\n    } else {\n      return false;\n    }\n  }\n\n  return false;\n}"]},"metadata":{},"sourceType":"script"}