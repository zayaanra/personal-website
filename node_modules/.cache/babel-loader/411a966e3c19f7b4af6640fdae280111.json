{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperGetFunctionArity = require(\"@babel/helper-get-function-arity\");\n\nvar _template = require(\"@babel/template\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  cloneNode,\n  identifier,\n  isAssignmentExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isRegExpLiteral,\n  isTemplateLiteral,\n  isVariableDeclarator,\n  toBindingIdentifierName\n} = _t;\nconst buildPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default(_ref) {\n  let {\n    node,\n    parent,\n    scope,\n    id\n  } = _ref;\n  let localBinding = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  let supportUnicodeId = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (node.id) return;\n\n  if ((isObjectProperty(parent) || isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = cloneNode(id);\n        node.id[NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  if (!supportUnicodeId && isFunction(node) && /[\\uD800-\\uDFFF]/.test(name)) {\n    return;\n  }\n\n  name = toBindingIdentifierName(name);\n  id = identifier(name);\n  id[NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/helper-function-name/lib/index.js"],"names":["Object","defineProperty","exports","value","default","_default","_helperGetFunctionArity","require","_template","_t","NOT_LOCAL_BINDING","cloneNode","identifier","isAssignmentExpression","isFunction","isIdentifier","isLiteral","isNullLiteral","isObjectMethod","isObjectProperty","isRegExpLiteral","isTemplateLiteral","isVariableDeclarator","toBindingIdentifierName","buildPropertyMethodAssignmentWrapper","buildGeneratorPropertyMethodAssignmentWrapper","visitor","path","state","node","name","localDeclar","scope","getBindingIdentifier","outerDeclar","selfReference","stop","getNameFromLiteralId","id","pattern","flags","quasis","map","quasi","raw","join","undefined","wrap","method","hasBinding","hasGlobal","rename","build","generator","template","FUNCTION","FUNCTION_ID","FUNCTION_KEY","generateUidIdentifier","expression","params","callee","body","i","len","push","getProgramParent","references","visit","selfAssignment","binding","getOwnBinding","kind","traverse","parent","localBinding","supportUnicodeId","computed","key","getBinding","constant","operator","left","test"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\n\nvar _helperGetFunctionArity = require(\"@babel/helper-get-function-arity\");\n\nvar _template = require(\"@babel/template\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  cloneNode,\n  identifier,\n  isAssignmentExpression,\n  isFunction,\n  isIdentifier,\n  isLiteral,\n  isNullLiteral,\n  isObjectMethod,\n  isObjectProperty,\n  isRegExpLiteral,\n  isTemplateLiteral,\n  isVariableDeclarator,\n  toBindingIdentifierName\n} = _t;\nconst buildPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst buildGeneratorPropertyMethodAssignmentWrapper = (0, _template.default)(`\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n`);\nconst visitor = {\n  \"ReferencedIdentifier|BindingIdentifier\"(path, state) {\n    if (path.node.name !== state.name) return;\n    const localDeclar = path.scope.getBindingIdentifier(state.name);\n    if (localDeclar !== state.outerDeclar) return;\n    state.selfReference = true;\n    path.stop();\n  }\n\n};\n\nfunction getNameFromLiteralId(id) {\n  if (isNullLiteral(id)) {\n    return \"null\";\n  }\n\n  if (isRegExpLiteral(id)) {\n    return `_${id.pattern}_${id.flags}`;\n  }\n\n  if (isTemplateLiteral(id)) {\n    return id.quasis.map(quasi => quasi.value.raw).join(\"\");\n  }\n\n  if (id.value !== undefined) {\n    return id.value + \"\";\n  }\n\n  return \"\";\n}\n\nfunction wrap(state, method, id, scope) {\n  if (state.selfReference) {\n    if (scope.hasBinding(id.name) && !scope.hasGlobal(id.name)) {\n      scope.rename(id.name);\n    } else {\n      if (!isFunction(method)) return;\n      let build = buildPropertyMethodAssignmentWrapper;\n\n      if (method.generator) {\n        build = buildGeneratorPropertyMethodAssignmentWrapper;\n      }\n\n      const template = build({\n        FUNCTION: method,\n        FUNCTION_ID: id,\n        FUNCTION_KEY: scope.generateUidIdentifier(id.name)\n      }).expression;\n      const params = template.callee.body.body[0].params;\n\n      for (let i = 0, len = (0, _helperGetFunctionArity.default)(method); i < len; i++) {\n        params.push(scope.generateUidIdentifier(\"x\"));\n      }\n\n      return template;\n    }\n  }\n\n  method.id = id;\n  scope.getProgramParent().references[id.name] = true;\n}\n\nfunction visit(node, name, scope) {\n  const state = {\n    selfAssignment: false,\n    selfReference: false,\n    outerDeclar: scope.getBindingIdentifier(name),\n    references: [],\n    name: name\n  };\n  const binding = scope.getOwnBinding(name);\n\n  if (binding) {\n    if (binding.kind === \"param\") {\n      state.selfReference = true;\n    } else {}\n  } else if (state.outerDeclar || scope.hasGlobal(name)) {\n    scope.traverse(node, visitor, state);\n  }\n\n  return state;\n}\n\nfunction _default({\n  node,\n  parent,\n  scope,\n  id\n}, localBinding = false, supportUnicodeId = false) {\n  if (node.id) return;\n\n  if ((isObjectProperty(parent) || isObjectMethod(parent, {\n    kind: \"method\"\n  })) && (!parent.computed || isLiteral(parent.key))) {\n    id = parent.key;\n  } else if (isVariableDeclarator(parent)) {\n    id = parent.id;\n\n    if (isIdentifier(id) && !localBinding) {\n      const binding = scope.parent.getBinding(id.name);\n\n      if (binding && binding.constant && scope.getBinding(id.name) === binding) {\n        node.id = cloneNode(id);\n        node.id[NOT_LOCAL_BINDING] = true;\n        return;\n      }\n    }\n  } else if (isAssignmentExpression(parent, {\n    operator: \"=\"\n  })) {\n    id = parent.left;\n  } else if (!id) {\n    return;\n  }\n\n  let name;\n\n  if (id && isLiteral(id)) {\n    name = getNameFromLiteralId(id);\n  } else if (id && isIdentifier(id)) {\n    name = id.name;\n  }\n\n  if (name === undefined) {\n    return;\n  }\n\n  if (!supportUnicodeId && isFunction(node) && /[\\uD800-\\uDFFF]/.test(name)) {\n    return;\n  }\n\n  name = toBindingIdentifierName(name);\n  id = identifier(name);\n  id[NOT_LOCAL_BINDING] = true;\n  const state = visit(node, name, scope);\n  return wrap(state, node, id, scope) || node;\n}"]},"metadata":{},"sourceType":"script"}