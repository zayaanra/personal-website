{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid() {\n    let name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"temp\";\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path) {\n    let bindingPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : path;\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind() {\n    const ids = Object.create(null);\n\n    for (var _len = arguments.length, kinds = new Array(_len), _key = 0; _key < _len; _key++) {\n      kinds[_key] = arguments[_key];\n    }\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/traverse/lib/scope/index.js"],"names":["Object","defineProperty","exports","value","default","_renamer","require","_index","_binding","_globals","_t","_cache","NOT_LOCAL_BINDING","callExpression","cloneNode","getBindingIdentifiers","identifier","isArrayExpression","isBinary","isClass","isClassBody","isClassDeclaration","isExportAllDeclaration","isExportDefaultDeclaration","isExportNamedDeclaration","isFunctionDeclaration","isIdentifier","isImportDeclaration","isLiteral","isMethod","isModuleDeclaration","isModuleSpecifier","isObjectExpression","isProperty","isPureish","isSuper","isTaggedTemplateExpression","isTemplateLiteral","isThisExpression","isUnaryExpression","isVariableDeclaration","matchesPattern","memberExpression","numericLiteral","toIdentifier","unaryExpression","variableDeclaration","variableDeclarator","gatherNodeParts","node","parts","type","source","specifiers","length","e","declaration","local","push","object","property","name","callee","properties","argument","key","left","id","expression","meta","openingElement","openingFragment","namespace","collectorVisitor","ForStatement","path","declar","get","isVar","scope","parentScope","getFunctionParent","getProgramParent","registerBinding","Declaration","isBlockScoped","isExportDeclaration","parent","registerDeclaration","ImportDeclaration","getBlockParent","ReferencedIdentifier","state","references","ForXStatement","isPattern","constantViolations","ExportDeclaration","exit","binding","getBinding","reference","decl","declarations","keys","LabeledStatement","AssignmentExpression","assignments","UpdateExpression","UnaryExpression","operator","BlockScoped","bindings","CatchClause","Function","params","param","isFunctionExpression","has","ClassExpression","uid","Scope","constructor","block","labels","inited","globals","uids","data","crawling","cached","set","Map","_parent","isKey","parentPath","isScope","parentBlock","hub","traverse","opts","generateDeclaredUidIdentifier","generateUidIdentifier","generateUid","replace","i","_generateUid","hasLabel","hasBinding","hasGlobal","hasReference","program","generateUidBasedOnNode","defaultName","join","slice","generateUidIdentifierBasedOnNode","isStatic","constant","maybeGenerateMemoised","dontPush","checkBlockScopedCollisions","kind","duplicate","buildError","TypeError","rename","oldName","newName","_renameFromMap","map","dump","sep","repeat","console","log","violations","toArray","arrayLikeIsIterable","isGenericType","helperName","args","unshift","addHelper","getLabel","registerLabel","label","isLabeledStatement","declare","specifier","buildUndefinedNode","registerConstantViolation","ids","reassign","bindingPath","ReferenceError","declarators","getOuterBindingIdentifiers","getOwnBinding","addGlobal","hasUid","isPure","constantsOnly","superClass","body","method","right","elem","elements","prop","computed","tag","quasi","expressions","setData","val","getData","removeData","init","crawl","create","programParent","_exploded","visit","enter","typeVisitors","ref","isBlockStatement","isProgram","isSwitchStatement","isLoop","isCatchClause","isFunction","ensureBlock","unique","blockHoist","_blockHoist","dataKey","declarPath","unshiftContainer","declarator","pop","Error","isFunctionParent","isBlockParent","getAllBindings","getAllBindingsOfKind","kinds","bindingIdentifierEquals","getBindingIdentifier","previousPath","_previousPath","isArrowFunctionExpression","_this$getBinding","getOwnBindingIdentifier","hasOwnBinding","noGlobals","parentHasBinding","includes","contextVariables","_this$parent","moveBindingTo","info","removeOwnBinding","removeBinding","_this$getBinding2","builtin"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkB,KAAK,CAAvB;;AAEA,IAAIC,QAAQ,GAAGC,OAAO,CAAC,eAAD,CAAtB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,UAAD,CAApB;;AAEA,IAAIE,QAAQ,GAAGF,OAAO,CAAC,WAAD,CAAtB;;AAEA,IAAIG,QAAQ,GAAGH,OAAO,CAAC,SAAD,CAAtB;;AAEA,IAAII,EAAE,GAAGJ,OAAO,CAAC,cAAD,CAAhB;;AAEA,IAAIK,MAAM,GAAGL,OAAO,CAAC,UAAD,CAApB;;AAEA,MAAM;AACJM,EAAAA,iBADI;AAEJC,EAAAA,cAFI;AAGJC,EAAAA,SAHI;AAIJC,EAAAA,qBAJI;AAKJC,EAAAA,UALI;AAMJC,EAAAA,iBANI;AAOJC,EAAAA,QAPI;AAQJC,EAAAA,OARI;AASJC,EAAAA,WATI;AAUJC,EAAAA,kBAVI;AAWJC,EAAAA,sBAXI;AAYJC,EAAAA,0BAZI;AAaJC,EAAAA,wBAbI;AAcJC,EAAAA,qBAdI;AAeJC,EAAAA,YAfI;AAgBJC,EAAAA,mBAhBI;AAiBJC,EAAAA,SAjBI;AAkBJC,EAAAA,QAlBI;AAmBJC,EAAAA,mBAnBI;AAoBJC,EAAAA,iBApBI;AAqBJC,EAAAA,kBArBI;AAsBJC,EAAAA,UAtBI;AAuBJC,EAAAA,SAvBI;AAwBJC,EAAAA,OAxBI;AAyBJC,EAAAA,0BAzBI;AA0BJC,EAAAA,iBA1BI;AA2BJC,EAAAA,gBA3BI;AA4BJC,EAAAA,iBA5BI;AA6BJC,EAAAA,qBA7BI;AA8BJC,EAAAA,cA9BI;AA+BJC,EAAAA,gBA/BI;AAgCJC,EAAAA,cAhCI;AAiCJC,EAAAA,YAjCI;AAkCJC,EAAAA,eAlCI;AAmCJC,EAAAA,mBAnCI;AAoCJC,EAAAA;AApCI,IAqCFrC,EArCJ;;AAuCA,SAASsC,eAAT,CAAyBC,IAAzB,EAA+BC,KAA/B,EAAsC;AACpC,UAAQD,IAAI,IAAI,IAAR,GAAe,KAAK,CAApB,GAAwBA,IAAI,CAACE,IAArC;AACE;AACE,UAAIrB,mBAAmB,CAACmB,IAAD,CAAvB,EAA+B;AAC7B,YAAI,CAAC3B,sBAAsB,CAAC2B,IAAD,CAAtB,IAAgCzB,wBAAwB,CAACyB,IAAD,CAAxD,IAAkEtB,mBAAmB,CAACsB,IAAD,CAAtF,KAAiGA,IAAI,CAACG,MAA1G,EAAkH;AAChHJ,UAAAA,eAAe,CAACC,IAAI,CAACG,MAAN,EAAcF,KAAd,CAAf;AACD,SAFD,MAEO,IAAI,CAAC1B,wBAAwB,CAACyB,IAAD,CAAxB,IAAkCtB,mBAAmB,CAACsB,IAAD,CAAtD,KAAiEA,IAAI,CAACI,UAAtE,IAAoFJ,IAAI,CAACI,UAAL,CAAgBC,MAAxG,EAAgH;AACrH,eAAK,MAAMC,CAAX,IAAgBN,IAAI,CAACI,UAArB,EAAiCL,eAAe,CAACO,CAAD,EAAIL,KAAJ,CAAf;AAClC,SAFM,MAEA,IAAI,CAAC3B,0BAA0B,CAAC0B,IAAD,CAA1B,IAAoCzB,wBAAwB,CAACyB,IAAD,CAA7D,KAAwEA,IAAI,CAACO,WAAjF,EAA8F;AACnGR,UAAAA,eAAe,CAACC,IAAI,CAACO,WAAN,EAAmBN,KAAnB,CAAf;AACD;AACF,OARD,MAQO,IAAInB,iBAAiB,CAACkB,IAAD,CAArB,EAA6B;AAClCD,QAAAA,eAAe,CAACC,IAAI,CAACQ,KAAN,EAAaP,KAAb,CAAf;AACD,OAFM,MAEA,IAAItB,SAAS,CAACqB,IAAD,CAAb,EAAqB;AAC1BC,QAAAA,KAAK,CAACQ,IAAN,CAAWT,IAAI,CAAC9C,KAAhB;AACD;;AAED;;AAEF,SAAK,kBAAL;AACA,SAAK,0BAAL;AACA,SAAK,qBAAL;AACE6C,MAAAA,eAAe,CAACC,IAAI,CAACU,MAAN,EAAcT,KAAd,CAAf;AACAF,MAAAA,eAAe,CAACC,IAAI,CAACW,QAAN,EAAgBV,KAAhB,CAAf;AACA;;AAEF,SAAK,YAAL;AACA,SAAK,eAAL;AACEA,MAAAA,KAAK,CAACQ,IAAN,CAAWT,IAAI,CAACY,IAAhB;AACA;;AAEF,SAAK,gBAAL;AACA,SAAK,wBAAL;AACA,SAAK,eAAL;AACEb,MAAAA,eAAe,CAACC,IAAI,CAACa,MAAN,EAAcZ,KAAd,CAAf;AACA;;AAEF,SAAK,kBAAL;AACA,SAAK,eAAL;AACE,WAAK,MAAMK,CAAX,IAAgBN,IAAI,CAACc,UAArB,EAAiC;AAC/Bf,QAAAA,eAAe,CAACO,CAAD,EAAIL,KAAJ,CAAf;AACD;;AAED;;AAEF,SAAK,eAAL;AACA,SAAK,aAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACe,QAAN,EAAgBd,KAAhB,CAAf;AACA;;AAEF,SAAK,gBAAL;AACA,SAAK,cAAL;AACA,SAAK,eAAL;AACA,SAAK,aAAL;AACA,SAAK,sBAAL;AACA,SAAK,oBAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACgB,GAAN,EAAWf,KAAX,CAAf;AACA;;AAEF,SAAK,gBAAL;AACEA,MAAAA,KAAK,CAACQ,IAAN,CAAW,MAAX;AACA;;AAEF,SAAK,OAAL;AACER,MAAAA,KAAK,CAACQ,IAAN,CAAW,OAAX;AACA;;AAEF,SAAK,QAAL;AACER,MAAAA,KAAK,CAACQ,IAAN,CAAW,QAAX;AACA;;AAEF,SAAK,cAAL;AACER,MAAAA,KAAK,CAACQ,IAAN,CAAW,IAAX;AACA;;AAEF,SAAK,iBAAL;AACER,MAAAA,KAAK,CAACQ,IAAN,CAAW,OAAX;AACAV,MAAAA,eAAe,CAACC,IAAI,CAACe,QAAN,EAAgBd,KAAhB,CAAf;AACA;;AAEF,SAAK,iBAAL;AACEA,MAAAA,KAAK,CAACQ,IAAN,CAAW,OAAX;AACAV,MAAAA,eAAe,CAACC,IAAI,CAACe,QAAN,EAAgBd,KAAhB,CAAf;AACA;;AAEF,SAAK,sBAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACiB,IAAN,EAAYhB,KAAZ,CAAf;AACA;;AAEF,SAAK,oBAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACkB,EAAN,EAAUjB,KAAV,CAAf;AACA;;AAEF,SAAK,oBAAL;AACA,SAAK,qBAAL;AACA,SAAK,iBAAL;AACA,SAAK,kBAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACkB,EAAN,EAAUjB,KAAV,CAAf;AACA;;AAEF,SAAK,aAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACkB,EAAN,EAAUjB,KAAV,CAAf;AACA;;AAEF,SAAK,yBAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACmB,UAAN,EAAkBlB,KAAlB,CAAf;AACA;;AAEF,SAAK,iBAAL;AACA,SAAK,kBAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACe,QAAN,EAAgBd,KAAhB,CAAf;AACA;;AAEF,SAAK,cAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACoB,IAAN,EAAYnB,KAAZ,CAAf;AACAF,MAAAA,eAAe,CAACC,IAAI,CAACW,QAAN,EAAgBV,KAAhB,CAAf;AACA;;AAEF,SAAK,YAAL;AACEF,MAAAA,eAAe,CAACC,IAAI,CAACqB,cAAN,EAAsBpB,KAAtB,CAAf;AACA;;AAEF,SAAK,mBAAL;AACEA,MAAAA,KAAK,CAACQ,IAAN,CAAWT,IAAI,CAACY,IAAhB;AACA;;AAEF,SAAK,aAAL;AACEb,MAAAA,eAAe,CAACC,IAAI,CAACsB,eAAN,EAAuBrB,KAAvB,CAAf;AACA;;AAEF,SAAK,oBAAL;AACEA,MAAAA,KAAK,CAACQ,IAAN,CAAW,UAAX;AACA;;AAEF,SAAK,mBAAL;AACEV,MAAAA,eAAe,CAACC,IAAI,CAACuB,SAAN,EAAiBtB,KAAjB,CAAf;AACAF,MAAAA,eAAe,CAACC,IAAI,CAACY,IAAN,EAAYX,KAAZ,CAAf;AACA;AAxIJ;AA0ID;;AAED,MAAMuB,gBAAgB,GAAG;AACvBC,EAAAA,YAAY,CAACC,IAAD,EAAO;AACjB,UAAMC,MAAM,GAAGD,IAAI,CAACE,GAAL,CAAS,MAAT,CAAf;;AAEA,QAAID,MAAM,CAACE,KAAP,EAAJ,EAAoB;AAClB,YAAM;AACJC,QAAAA;AADI,UAEFJ,IAFJ;AAGA,YAAMK,WAAW,GAAGD,KAAK,CAACE,iBAAN,MAA6BF,KAAK,CAACG,gBAAN,EAAjD;AACAF,MAAAA,WAAW,CAACG,eAAZ,CAA4B,KAA5B,EAAmCP,MAAnC;AACD;AACF,GAXsB;;AAavBQ,EAAAA,WAAW,CAACT,IAAD,EAAO;AAChB,QAAIA,IAAI,CAACU,aAAL,EAAJ,EAA0B;AAC1B,QAAIV,IAAI,CAAChD,mBAAL,EAAJ,EAAgC;AAChC,QAAIgD,IAAI,CAACW,mBAAL,EAAJ,EAAgC;AAChC,UAAMC,MAAM,GAAGZ,IAAI,CAACI,KAAL,CAAWE,iBAAX,MAAkCN,IAAI,CAACI,KAAL,CAAWG,gBAAX,EAAjD;AACAK,IAAAA,MAAM,CAACC,mBAAP,CAA2Bb,IAA3B;AACD,GAnBsB;;AAqBvBc,EAAAA,iBAAiB,CAACd,IAAD,EAAO;AACtB,UAAMY,MAAM,GAAGZ,IAAI,CAACI,KAAL,CAAWW,cAAX,EAAf;AACAH,IAAAA,MAAM,CAACC,mBAAP,CAA2Bb,IAA3B;AACD,GAxBsB;;AA0BvBgB,EAAAA,oBAAoB,CAAChB,IAAD,EAAOiB,KAAP,EAAc;AAChCA,IAAAA,KAAK,CAACC,UAAN,CAAiBnC,IAAjB,CAAsBiB,IAAtB;AACD,GA5BsB;;AA8BvBmB,EAAAA,aAAa,CAACnB,IAAD,EAAOiB,KAAP,EAAc;AACzB,UAAM1B,IAAI,GAAGS,IAAI,CAACE,GAAL,CAAS,MAAT,CAAb;;AAEA,QAAIX,IAAI,CAAC6B,SAAL,MAAoB7B,IAAI,CAACxC,YAAL,EAAxB,EAA6C;AAC3CkE,MAAAA,KAAK,CAACI,kBAAN,CAAyBtC,IAAzB,CAA8BiB,IAA9B;AACD,KAFD,MAEO,IAAIT,IAAI,CAACY,KAAL,EAAJ,EAAkB;AACvB,YAAM;AACJC,QAAAA;AADI,UAEFJ,IAFJ;AAGA,YAAMK,WAAW,GAAGD,KAAK,CAACE,iBAAN,MAA6BF,KAAK,CAACG,gBAAN,EAAjD;AACAF,MAAAA,WAAW,CAACG,eAAZ,CAA4B,KAA5B,EAAmCjB,IAAnC;AACD;AACF,GA1CsB;;AA4CvB+B,EAAAA,iBAAiB,EAAE;AACjBC,IAAAA,IAAI,CAACvB,IAAD,EAAO;AACT,YAAM;AACJ1B,QAAAA,IADI;AAEJ8B,QAAAA;AAFI,UAGFJ,IAHJ;AAIA,UAAIrD,sBAAsB,CAAC2B,IAAD,CAA1B,EAAkC;AAClC,YAAM2B,MAAM,GAAG3B,IAAI,CAACO,WAApB;;AAEA,UAAInC,kBAAkB,CAACuD,MAAD,CAAlB,IAA8BnD,qBAAqB,CAACmD,MAAD,CAAvD,EAAiE;AAC/D,cAAMT,EAAE,GAAGS,MAAM,CAACT,EAAlB;AACA,YAAI,CAACA,EAAL,EAAS;AACT,cAAMgC,OAAO,GAAGpB,KAAK,CAACqB,UAAN,CAAiBjC,EAAE,CAACN,IAApB,CAAhB;AACAsC,QAAAA,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACE,SAAR,CAAkB1B,IAAlB,CAA3B;AACD,OALD,MAKO,IAAInC,qBAAqB,CAACoC,MAAD,CAAzB,EAAmC;AACxC,aAAK,MAAM0B,IAAX,IAAmB1B,MAAM,CAAC2B,YAA1B,EAAwC;AACtC,eAAK,MAAM1C,IAAX,IAAmB7D,MAAM,CAACwG,IAAP,CAAYzF,qBAAqB,CAACuF,IAAD,CAAjC,CAAnB,EAA6D;AAC3D,kBAAMH,OAAO,GAAGpB,KAAK,CAACqB,UAAN,CAAiBvC,IAAjB,CAAhB;AACAsC,YAAAA,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACE,SAAR,CAAkB1B,IAAlB,CAA3B;AACD;AACF;AACF;AACF;;AAtBgB,GA5CI;;AAsEvB8B,EAAAA,gBAAgB,CAAC9B,IAAD,EAAO;AACrBA,IAAAA,IAAI,CAACI,KAAL,CAAWW,cAAX,GAA4BF,mBAA5B,CAAgDb,IAAhD;AACD,GAxEsB;;AA0EvB+B,EAAAA,oBAAoB,CAAC/B,IAAD,EAAOiB,KAAP,EAAc;AAChCA,IAAAA,KAAK,CAACe,WAAN,CAAkBjD,IAAlB,CAAuBiB,IAAvB;AACD,GA5EsB;;AA8EvBiC,EAAAA,gBAAgB,CAACjC,IAAD,EAAOiB,KAAP,EAAc;AAC5BA,IAAAA,KAAK,CAACI,kBAAN,CAAyBtC,IAAzB,CAA8BiB,IAA9B;AACD,GAhFsB;;AAkFvBkC,EAAAA,eAAe,CAAClC,IAAD,EAAOiB,KAAP,EAAc;AAC3B,QAAIjB,IAAI,CAAC1B,IAAL,CAAU6D,QAAV,KAAuB,QAA3B,EAAqC;AACnClB,MAAAA,KAAK,CAACI,kBAAN,CAAyBtC,IAAzB,CAA8BiB,IAA9B;AACD;AACF,GAtFsB;;AAwFvBoC,EAAAA,WAAW,CAACpC,IAAD,EAAO;AAChB,QAAII,KAAK,GAAGJ,IAAI,CAACI,KAAjB;AACA,QAAIA,KAAK,CAACJ,IAAN,KAAeA,IAAnB,EAAyBI,KAAK,GAAGA,KAAK,CAACQ,MAAd;AACzB,UAAMA,MAAM,GAAGR,KAAK,CAACW,cAAN,EAAf;AACAH,IAAAA,MAAM,CAACC,mBAAP,CAA2Bb,IAA3B;;AAEA,QAAIA,IAAI,CAACtD,kBAAL,MAA6BsD,IAAI,CAAC1B,IAAL,CAAUkB,EAA3C,EAA+C;AAC7C,YAAMA,EAAE,GAAGQ,IAAI,CAAC1B,IAAL,CAAUkB,EAArB;AACA,YAAMN,IAAI,GAAGM,EAAE,CAACN,IAAhB;AACAc,MAAAA,IAAI,CAACI,KAAL,CAAWiC,QAAX,CAAoBnD,IAApB,IAA4Bc,IAAI,CAACI,KAAL,CAAWQ,MAAX,CAAkBa,UAAlB,CAA6BvC,IAA7B,CAA5B;AACD;AACF,GAnGsB;;AAqGvBoD,EAAAA,WAAW,CAACtC,IAAD,EAAO;AAChBA,IAAAA,IAAI,CAACI,KAAL,CAAWI,eAAX,CAA2B,KAA3B,EAAkCR,IAAlC;AACD,GAvGsB;;AAyGvBuC,EAAAA,QAAQ,CAACvC,IAAD,EAAO;AACb,UAAMwC,MAAM,GAAGxC,IAAI,CAACE,GAAL,CAAS,QAAT,CAAf;;AAEA,SAAK,MAAMuC,KAAX,IAAoBD,MAApB,EAA4B;AAC1BxC,MAAAA,IAAI,CAACI,KAAL,CAAWI,eAAX,CAA2B,OAA3B,EAAoCiC,KAApC;AACD;;AAED,QAAIzC,IAAI,CAAC0C,oBAAL,MAA+B1C,IAAI,CAAC2C,GAAL,CAAS,IAAT,CAA/B,IAAiD,CAAC3C,IAAI,CAACE,GAAL,CAAS,IAAT,EAAe5B,IAAf,CAAoBrC,iBAApB,CAAtD,EAA8F;AAC5F+D,MAAAA,IAAI,CAACI,KAAL,CAAWI,eAAX,CAA2B,OAA3B,EAAoCR,IAAI,CAACE,GAAL,CAAS,IAAT,CAApC,EAAoDF,IAApD;AACD;AACF,GAnHsB;;AAqHvB4C,EAAAA,eAAe,CAAC5C,IAAD,EAAO;AACpB,QAAIA,IAAI,CAAC2C,GAAL,CAAS,IAAT,KAAkB,CAAC3C,IAAI,CAACE,GAAL,CAAS,IAAT,EAAe5B,IAAf,CAAoBrC,iBAApB,CAAvB,EAA+D;AAC7D+D,MAAAA,IAAI,CAACI,KAAL,CAAWI,eAAX,CAA2B,OAA3B,EAAoCR,IAApC;AACD;AACF;;AAzHsB,CAAzB;AA4HA,IAAI6C,GAAG,GAAG,CAAV;;AAEA,MAAMC,KAAN,CAAY;AACVC,EAAAA,WAAW,CAAC/C,IAAD,EAAO;AAChB,SAAK6C,GAAL,GAAW,KAAK,CAAhB;AACA,SAAK7C,IAAL,GAAY,KAAK,CAAjB;AACA,SAAKgD,KAAL,GAAa,KAAK,CAAlB;AACA,SAAKC,MAAL,GAAc,KAAK,CAAnB;AACA,SAAKC,MAAL,GAAc,KAAK,CAAnB;AACA,SAAKb,QAAL,GAAgB,KAAK,CAArB;AACA,SAAKnB,UAAL,GAAkB,KAAK,CAAvB;AACA,SAAKiC,OAAL,GAAe,KAAK,CAApB;AACA,SAAKC,IAAL,GAAY,KAAK,CAAjB;AACA,SAAKC,IAAL,GAAY,KAAK,CAAjB;AACA,SAAKC,QAAL,GAAgB,KAAK,CAArB;AACA,UAAM;AACJhF,MAAAA;AADI,QAEF0B,IAFJ;;AAIA,UAAMuD,MAAM,GAAGvH,MAAM,CAACoE,KAAP,CAAaF,GAAb,CAAiB5B,IAAjB,CAAf;;AAEA,QAAI,CAACiF,MAAM,IAAI,IAAV,GAAiB,KAAK,CAAtB,GAA0BA,MAAM,CAACvD,IAAlC,MAA4CA,IAAhD,EAAsD;AACpD,aAAOuD,MAAP;AACD;;AAEDvH,IAAAA,MAAM,CAACoE,KAAP,CAAaoD,GAAb,CAAiBlF,IAAjB,EAAuB,IAAvB;;AAEA,SAAKuE,GAAL,GAAWA,GAAG,EAAd;AACA,SAAKG,KAAL,GAAa1E,IAAb;AACA,SAAK0B,IAAL,GAAYA,IAAZ;AACA,SAAKiD,MAAL,GAAc,IAAIQ,GAAJ,EAAd;AACA,SAAKP,MAAL,GAAc,KAAd;AACD;;AAES,MAANtC,MAAM,GAAG;AACX,QAAI8C,OAAJ;;AAEA,QAAI9C,MAAJ;AAAA,QACIZ,IAAI,GAAG,KAAKA,IADhB;;AAGA,OAAG;AACD,YAAM2D,KAAK,GAAG3D,IAAI,CAACV,GAAL,KAAa,KAA3B;AACAU,MAAAA,IAAI,GAAGA,IAAI,CAAC4D,UAAZ;AACA,UAAID,KAAK,IAAI3D,IAAI,CAAC9C,QAAL,EAAb,EAA8B8C,IAAI,GAAGA,IAAI,CAAC4D,UAAZ;AAC9B,UAAI5D,IAAI,IAAIA,IAAI,CAAC6D,OAAL,EAAZ,EAA4BjD,MAAM,GAAGZ,IAAT;AAC7B,KALD,QAKSA,IAAI,IAAI,CAACY,MALlB;;AAOA,WAAO,CAAC8C,OAAO,GAAG9C,MAAX,KAAsB,IAAtB,GAA6B,KAAK,CAAlC,GAAsC8C,OAAO,CAACtD,KAArD;AACD;;AAEc,MAAX0D,WAAW,GAAG;AAChB,WAAO,KAAK9D,IAAL,CAAUY,MAAjB;AACD;;AAEM,MAAHmD,GAAG,GAAG;AACR,WAAO,KAAK/D,IAAL,CAAU+D,GAAjB;AACD;;AAEDC,EAAAA,QAAQ,CAAC1F,IAAD,EAAO2F,IAAP,EAAahD,KAAb,EAAoB;AAC1B,KAAC,GAAGrF,MAAM,CAACH,OAAX,EAAoB6C,IAApB,EAA0B2F,IAA1B,EAAgC,IAAhC,EAAsChD,KAAtC,EAA6C,KAAKjB,IAAlD;AACD;;AAEDkE,EAAAA,6BAA6B,CAAChF,IAAD,EAAO;AAClC,UAAMM,EAAE,GAAG,KAAK2E,qBAAL,CAA2BjF,IAA3B,CAAX;AACA,SAAKH,IAAL,CAAU;AACRS,MAAAA;AADQ,KAAV;AAGA,WAAOrD,SAAS,CAACqD,EAAD,CAAhB;AACD;;AAED2E,EAAAA,qBAAqB,CAACjF,IAAD,EAAO;AAC1B,WAAO7C,UAAU,CAAC,KAAK+H,WAAL,CAAiBlF,IAAjB,CAAD,CAAjB;AACD;;AAEDkF,EAAAA,WAAW,GAAgB;AAAA,QAAflF,IAAe,uEAAR,MAAQ;AACzBA,IAAAA,IAAI,GAAGjB,YAAY,CAACiB,IAAD,CAAZ,CAAmBmF,OAAnB,CAA2B,KAA3B,EAAkC,EAAlC,EAAsCA,OAAtC,CAA8C,UAA9C,EAA0D,EAA1D,CAAP;AACA,QAAIxB,GAAJ;AACA,QAAIyB,CAAC,GAAG,CAAR;;AAEA,OAAG;AACDzB,MAAAA,GAAG,GAAG,KAAK0B,YAAL,CAAkBrF,IAAlB,EAAwBoF,CAAxB,CAAN;AACAA,MAAAA,CAAC;AACF,KAHD,QAGS,KAAKE,QAAL,CAAc3B,GAAd,KAAsB,KAAK4B,UAAL,CAAgB5B,GAAhB,CAAtB,IAA8C,KAAK6B,SAAL,CAAe7B,GAAf,CAA9C,IAAqE,KAAK8B,YAAL,CAAkB9B,GAAlB,CAH9E;;AAKA,UAAM+B,OAAO,GAAG,KAAKrE,gBAAL,EAAhB;AACAqE,IAAAA,OAAO,CAAC1D,UAAR,CAAmB2B,GAAnB,IAA0B,IAA1B;AACA+B,IAAAA,OAAO,CAACxB,IAAR,CAAaP,GAAb,IAAoB,IAApB;AACA,WAAOA,GAAP;AACD;;AAED0B,EAAAA,YAAY,CAACrF,IAAD,EAAOoF,CAAP,EAAU;AACpB,QAAI9E,EAAE,GAAGN,IAAT;AACA,QAAIoF,CAAC,GAAG,CAAR,EAAW9E,EAAE,IAAI8E,CAAN;AACX,WAAQ,IAAG9E,EAAG,EAAd;AACD;;AAEDqF,EAAAA,sBAAsB,CAACvG,IAAD,EAAOwG,WAAP,EAAoB;AACxC,UAAMvG,KAAK,GAAG,EAAd;AACAF,IAAAA,eAAe,CAACC,IAAD,EAAOC,KAAP,CAAf;AACA,QAAIiB,EAAE,GAAGjB,KAAK,CAACwG,IAAN,CAAW,GAAX,CAAT;AACAvF,IAAAA,EAAE,GAAGA,EAAE,CAAC6E,OAAH,CAAW,IAAX,EAAiB,EAAjB,KAAwBS,WAAxB,IAAuC,KAA5C;AACA,WAAO,KAAKV,WAAL,CAAiB5E,EAAE,CAACwF,KAAH,CAAS,CAAT,EAAY,EAAZ,CAAjB,CAAP;AACD;;AAEDC,EAAAA,gCAAgC,CAAC3G,IAAD,EAAOwG,WAAP,EAAoB;AAClD,WAAOzI,UAAU,CAAC,KAAKwI,sBAAL,CAA4BvG,IAA5B,EAAkCwG,WAAlC,CAAD,CAAjB;AACD;;AAEDI,EAAAA,QAAQ,CAAC5G,IAAD,EAAO;AACb,QAAIX,gBAAgB,CAACW,IAAD,CAAhB,IAA0Bd,OAAO,CAACc,IAAD,CAArC,EAA6C;AAC3C,aAAO,IAAP;AACD;;AAED,QAAIvB,YAAY,CAACuB,IAAD,CAAhB,EAAwB;AACtB,YAAMkD,OAAO,GAAG,KAAKC,UAAL,CAAgBnD,IAAI,CAACY,IAArB,CAAhB;;AAEA,UAAIsC,OAAJ,EAAa;AACX,eAAOA,OAAO,CAAC2D,QAAf;AACD,OAFD,MAEO;AACL,eAAO,KAAKV,UAAL,CAAgBnG,IAAI,CAACY,IAArB,CAAP;AACD;AACF;;AAED,WAAO,KAAP;AACD;;AAEDkG,EAAAA,qBAAqB,CAAC9G,IAAD,EAAO+G,QAAP,EAAiB;AACpC,QAAI,KAAKH,QAAL,CAAc5G,IAAd,CAAJ,EAAyB;AACvB,aAAO,IAAP;AACD,KAFD,MAEO;AACL,YAAMkB,EAAE,GAAG,KAAKyF,gCAAL,CAAsC3G,IAAtC,CAAX;;AAEA,UAAI,CAAC+G,QAAL,EAAe;AACb,aAAKtG,IAAL,CAAU;AACRS,UAAAA;AADQ,SAAV;AAGA,eAAOrD,SAAS,CAACqD,EAAD,CAAhB;AACD;;AAED,aAAOA,EAAP;AACD;AACF;;AAED8F,EAAAA,0BAA0B,CAACxG,KAAD,EAAQyG,IAAR,EAAcrG,IAAd,EAAoBM,EAApB,EAAwB;AAChD,QAAI+F,IAAI,KAAK,OAAb,EAAsB;AACtB,QAAIzG,KAAK,CAACyG,IAAN,KAAe,OAAnB,EAA4B;AAC5B,UAAMC,SAAS,GAAGD,IAAI,KAAK,KAAT,IAAkBzG,KAAK,CAACyG,IAAN,KAAe,KAAjC,IAA0CzG,KAAK,CAACyG,IAAN,KAAe,OAAzD,IAAoEzG,KAAK,CAACyG,IAAN,KAAe,QAAnF,IAA+FzG,KAAK,CAACyG,IAAN,KAAe,OAAf,KAA2BA,IAAI,KAAK,KAAT,IAAkBA,IAAI,KAAK,OAAtD,CAAjH;;AAEA,QAAIC,SAAJ,EAAe;AACb,YAAM,KAAKzB,GAAL,CAAS0B,UAAT,CAAoBjG,EAApB,EAAyB,0BAAyBN,IAAK,GAAvD,EAA2DwG,SAA3D,CAAN;AACD;AACF;;AAEDC,EAAAA,MAAM,CAACC,OAAD,EAAUC,OAAV,EAAmB7C,KAAnB,EAA0B;AAC9B,UAAMxB,OAAO,GAAG,KAAKC,UAAL,CAAgBmE,OAAhB,CAAhB;;AAEA,QAAIpE,OAAJ,EAAa;AACXqE,MAAAA,OAAO,GAAGA,OAAO,IAAI,KAAK1B,qBAAL,CAA2ByB,OAA3B,EAAoC1G,IAAzD;AACA,aAAO,IAAIxD,QAAQ,CAACD,OAAb,CAAqB+F,OAArB,EAA8BoE,OAA9B,EAAuCC,OAAvC,EAAgDF,MAAhD,CAAuD3C,KAAvD,CAAP;AACD;AACF;;AAED8C,EAAAA,cAAc,CAACC,GAAD,EAAMH,OAAN,EAAeC,OAAf,EAAwBrK,KAAxB,EAA+B;AAC3C,QAAIuK,GAAG,CAACH,OAAD,CAAP,EAAkB;AAChBG,MAAAA,GAAG,CAACF,OAAD,CAAH,GAAerK,KAAf;AACAuK,MAAAA,GAAG,CAACH,OAAD,CAAH,GAAe,IAAf;AACD;AACF;;AAEDI,EAAAA,IAAI,GAAG;AACL,UAAMC,GAAG,GAAG,IAAIC,MAAJ,CAAW,EAAX,CAAZ;AACAC,IAAAA,OAAO,CAACC,GAAR,CAAYH,GAAZ;AACA,QAAI7F,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD+F,MAAAA,OAAO,CAACC,GAAR,CAAY,GAAZ,EAAiBhG,KAAK,CAAC4C,KAAN,CAAYxE,IAA7B;;AAEA,WAAK,MAAMU,IAAX,IAAmB7D,MAAM,CAACwG,IAAP,CAAYzB,KAAK,CAACiC,QAAlB,CAAnB,EAAgD;AAC9C,cAAMb,OAAO,GAAGpB,KAAK,CAACiC,QAAN,CAAenD,IAAf,CAAhB;AACAiH,QAAAA,OAAO,CAACC,GAAR,CAAY,IAAZ,EAAkBlH,IAAlB,EAAwB;AACtBiG,UAAAA,QAAQ,EAAE3D,OAAO,CAAC2D,QADI;AAEtBjE,UAAAA,UAAU,EAAEM,OAAO,CAACN,UAFE;AAGtBmF,UAAAA,UAAU,EAAE7E,OAAO,CAACH,kBAAR,CAA2B1C,MAHjB;AAItB4G,UAAAA,IAAI,EAAE/D,OAAO,CAAC+D;AAJQ,SAAxB;AAMD;AACF,KAZD,QAYSnF,KAAK,GAAGA,KAAK,CAACQ,MAZvB;;AAcAuF,IAAAA,OAAO,CAACC,GAAR,CAAYH,GAAZ;AACD;;AAEDK,EAAAA,OAAO,CAAChI,IAAD,EAAOgG,CAAP,EAAUiC,mBAAV,EAA+B;AACpC,QAAIxJ,YAAY,CAACuB,IAAD,CAAhB,EAAwB;AACtB,YAAMkD,OAAO,GAAG,KAAKC,UAAL,CAAgBnD,IAAI,CAACY,IAArB,CAAhB;;AAEA,UAAIsC,OAAO,IAAI,IAAX,IAAmBA,OAAO,CAAC2D,QAA3B,IAAuC3D,OAAO,CAACxB,IAAR,CAAawG,aAAb,CAA2B,OAA3B,CAA3C,EAAgF;AAC9E,eAAOlI,IAAP;AACD;AACF;;AAED,QAAIhC,iBAAiB,CAACgC,IAAD,CAArB,EAA6B;AAC3B,aAAOA,IAAP;AACD;;AAED,QAAIvB,YAAY,CAACuB,IAAD,EAAO;AACrBY,MAAAA,IAAI,EAAE;AADe,KAAP,CAAhB,EAEI;AACF,aAAOhD,cAAc,CAAC6B,gBAAgB,CAACA,gBAAgB,CAACA,gBAAgB,CAAC1B,UAAU,CAAC,OAAD,CAAX,EAAsBA,UAAU,CAAC,WAAD,CAAhC,CAAjB,EAAiEA,UAAU,CAAC,OAAD,CAA3E,CAAjB,EAAwGA,UAAU,CAAC,MAAD,CAAlH,CAAjB,EAA8I,CAACiC,IAAD,CAA9I,CAArB;AACD;;AAED,QAAImI,UAAJ;AACA,UAAMC,IAAI,GAAG,CAACpI,IAAD,CAAb;;AAEA,QAAIgG,CAAC,KAAK,IAAV,EAAgB;AACdmC,MAAAA,UAAU,GAAG,mBAAb;AACD,KAFD,MAEO,IAAInC,CAAJ,EAAO;AACZoC,MAAAA,IAAI,CAAC3H,IAAL,CAAUf,cAAc,CAACsG,CAAD,CAAxB;AACAmC,MAAAA,UAAU,GAAG,eAAb;AACD,KAHM,MAGA;AACLA,MAAAA,UAAU,GAAG,SAAb;AACD;;AAED,QAAIF,mBAAJ,EAAyB;AACvBG,MAAAA,IAAI,CAACC,OAAL,CAAa,KAAK5C,GAAL,CAAS6C,SAAT,CAAmBH,UAAnB,CAAb;AACAA,MAAAA,UAAU,GAAG,gBAAb;AACD;;AAED,WAAOvK,cAAc,CAAC,KAAK6H,GAAL,CAAS6C,SAAT,CAAmBH,UAAnB,CAAD,EAAiCC,IAAjC,CAArB;AACD;;AAEDlC,EAAAA,QAAQ,CAACtF,IAAD,EAAO;AACb,WAAO,CAAC,CAAC,KAAK2H,QAAL,CAAc3H,IAAd,CAAT;AACD;;AAED2H,EAAAA,QAAQ,CAAC3H,IAAD,EAAO;AACb,WAAO,KAAK+D,MAAL,CAAY/C,GAAZ,CAAgBhB,IAAhB,CAAP;AACD;;AAED4H,EAAAA,aAAa,CAAC9G,IAAD,EAAO;AAClB,SAAKiD,MAAL,CAAYO,GAAZ,CAAgBxD,IAAI,CAAC1B,IAAL,CAAUyI,KAAV,CAAgB7H,IAAhC,EAAsCc,IAAtC;AACD;;AAEDa,EAAAA,mBAAmB,CAACb,IAAD,EAAO;AACxB,QAAIA,IAAI,CAACgH,kBAAL,EAAJ,EAA+B;AAC7B,WAAKF,aAAL,CAAmB9G,IAAnB;AACD,KAFD,MAEO,IAAIA,IAAI,CAAClD,qBAAL,EAAJ,EAAkC;AACvC,WAAK0D,eAAL,CAAqB,SAArB,EAAgCR,IAAI,CAACE,GAAL,CAAS,IAAT,CAAhC,EAAgDF,IAAhD;AACD,KAFM,MAEA,IAAIA,IAAI,CAACnC,qBAAL,EAAJ,EAAkC;AACvC,YAAM+D,YAAY,GAAG5B,IAAI,CAACE,GAAL,CAAS,cAAT,CAArB;;AAEA,WAAK,MAAMD,MAAX,IAAqB2B,YAArB,EAAmC;AACjC,aAAKpB,eAAL,CAAqBR,IAAI,CAAC1B,IAAL,CAAUiH,IAA/B,EAAqCtF,MAArC;AACD;AACF,KANM,MAMA,IAAID,IAAI,CAACtD,kBAAL,EAAJ,EAA+B;AACpC,UAAIsD,IAAI,CAAC1B,IAAL,CAAU2I,OAAd,EAAuB;AACvB,WAAKzG,eAAL,CAAqB,KAArB,EAA4BR,IAA5B;AACD,KAHM,MAGA,IAAIA,IAAI,CAAChD,mBAAL,EAAJ,EAAgC;AACrC,YAAM0B,UAAU,GAAGsB,IAAI,CAACE,GAAL,CAAS,YAAT,CAAnB;;AAEA,WAAK,MAAMgH,SAAX,IAAwBxI,UAAxB,EAAoC;AAClC,aAAK8B,eAAL,CAAqB,QAArB,EAA+B0G,SAA/B;AACD;AACF,KANM,MAMA,IAAIlH,IAAI,CAACW,mBAAL,EAAJ,EAAgC;AACrC,YAAMV,MAAM,GAAGD,IAAI,CAACE,GAAL,CAAS,aAAT,CAAf;;AAEA,UAAID,MAAM,CAACvD,kBAAP,MAA+BuD,MAAM,CAACnD,qBAAP,EAA/B,IAAiEmD,MAAM,CAACpC,qBAAP,EAArE,EAAqG;AACnG,aAAKgD,mBAAL,CAAyBZ,MAAzB;AACD;AACF,KANM,MAMA;AACL,WAAKO,eAAL,CAAqB,SAArB,EAAgCR,IAAhC;AACD;AACF;;AAEDmH,EAAAA,kBAAkB,GAAG;AACnB,WAAOjJ,eAAe,CAAC,MAAD,EAASF,cAAc,CAAC,CAAD,CAAvB,EAA4B,IAA5B,CAAtB;AACD;;AAEDoJ,EAAAA,yBAAyB,CAACpH,IAAD,EAAO;AAC9B,UAAMqH,GAAG,GAAGrH,IAAI,CAAC5D,qBAAL,EAAZ;;AAEA,SAAK,MAAM8C,IAAX,IAAmB7D,MAAM,CAACwG,IAAP,CAAYwF,GAAZ,CAAnB,EAAqC;AACnC,YAAM7F,OAAO,GAAG,KAAKC,UAAL,CAAgBvC,IAAhB,CAAhB;AACA,UAAIsC,OAAJ,EAAaA,OAAO,CAAC8F,QAAR,CAAiBtH,IAAjB;AACd;AACF;;AAEDQ,EAAAA,eAAe,CAAC+E,IAAD,EAAOvF,IAAP,EAAiC;AAAA,QAApBuH,WAAoB,uEAANvH,IAAM;AAC9C,QAAI,CAACuF,IAAL,EAAW,MAAM,IAAIiC,cAAJ,CAAmB,WAAnB,CAAN;;AAEX,QAAIxH,IAAI,CAACnC,qBAAL,EAAJ,EAAkC;AAChC,YAAM4J,WAAW,GAAGzH,IAAI,CAACE,GAAL,CAAS,cAAT,CAApB;;AAEA,WAAK,MAAMD,MAAX,IAAqBwH,WAArB,EAAkC;AAChC,aAAKjH,eAAL,CAAqB+E,IAArB,EAA2BtF,MAA3B;AACD;;AAED;AACD;;AAED,UAAMW,MAAM,GAAG,KAAKL,gBAAL,EAAf;AACA,UAAM8G,GAAG,GAAGrH,IAAI,CAAC0H,0BAAL,CAAgC,IAAhC,CAAZ;;AAEA,SAAK,MAAMxI,IAAX,IAAmB7D,MAAM,CAACwG,IAAP,CAAYwF,GAAZ,CAAnB,EAAqC;AACnCzG,MAAAA,MAAM,CAACM,UAAP,CAAkBhC,IAAlB,IAA0B,IAA1B;;AAEA,WAAK,MAAMM,EAAX,IAAiB6H,GAAG,CAACnI,IAAD,CAApB,EAA4B;AAC1B,cAAMJ,KAAK,GAAG,KAAK6I,aAAL,CAAmBzI,IAAnB,CAAd;;AAEA,YAAIJ,KAAJ,EAAW;AACT,cAAIA,KAAK,CAACzC,UAAN,KAAqBmD,EAAzB,EAA6B;AAC7B,eAAK8F,0BAAL,CAAgCxG,KAAhC,EAAuCyG,IAAvC,EAA6CrG,IAA7C,EAAmDM,EAAnD;AACD;;AAED,YAAIV,KAAJ,EAAW;AACT,eAAKsI,yBAAL,CAA+BG,WAA/B;AACD,SAFD,MAEO;AACL,eAAKlF,QAAL,CAAcnD,IAAd,IAAsB,IAAIrD,QAAQ,CAACJ,OAAb,CAAqB;AACzCY,YAAAA,UAAU,EAAEmD,EAD6B;AAEzCY,YAAAA,KAAK,EAAE,IAFkC;AAGzCJ,YAAAA,IAAI,EAAEuH,WAHmC;AAIzChC,YAAAA,IAAI,EAAEA;AAJmC,WAArB,CAAtB;AAMD;AACF;AACF;AACF;;AAEDqC,EAAAA,SAAS,CAACtJ,IAAD,EAAO;AACd,SAAK6E,OAAL,CAAa7E,IAAI,CAACY,IAAlB,IAA0BZ,IAA1B;AACD;;AAEDuJ,EAAAA,MAAM,CAAC3I,IAAD,EAAO;AACX,QAAIkB,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,UAAIA,KAAK,CAACgD,IAAN,CAAWlE,IAAX,CAAJ,EAAsB,OAAO,IAAP;AACvB,KAFD,QAESkB,KAAK,GAAGA,KAAK,CAACQ,MAFvB;;AAIA,WAAO,KAAP;AACD;;AAED8D,EAAAA,SAAS,CAACxF,IAAD,EAAO;AACd,QAAIkB,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,UAAIA,KAAK,CAAC+C,OAAN,CAAcjE,IAAd,CAAJ,EAAyB,OAAO,IAAP;AAC1B,KAFD,QAESkB,KAAK,GAAGA,KAAK,CAACQ,MAFvB;;AAIA,WAAO,KAAP;AACD;;AAED+D,EAAAA,YAAY,CAACzF,IAAD,EAAO;AACjB,WAAO,CAAC,CAAC,KAAKqB,gBAAL,GAAwBW,UAAxB,CAAmChC,IAAnC,CAAT;AACD;;AAED4I,EAAAA,MAAM,CAACxJ,IAAD,EAAOyJ,aAAP,EAAsB;AAC1B,QAAIhL,YAAY,CAACuB,IAAD,CAAhB,EAAwB;AACtB,YAAMkD,OAAO,GAAG,KAAKC,UAAL,CAAgBnD,IAAI,CAACY,IAArB,CAAhB;AACA,UAAI,CAACsC,OAAL,EAAc,OAAO,KAAP;AACd,UAAIuG,aAAJ,EAAmB,OAAOvG,OAAO,CAAC2D,QAAf;AACnB,aAAO,IAAP;AACD,KALD,MAKO,IAAI3I,OAAO,CAAC8B,IAAD,CAAX,EAAmB;AACxB,UAAIA,IAAI,CAAC0J,UAAL,IAAmB,CAAC,KAAKF,MAAL,CAAYxJ,IAAI,CAAC0J,UAAjB,EAA6BD,aAA7B,CAAxB,EAAqE;AACnE,eAAO,KAAP;AACD;;AAED,aAAO,KAAKD,MAAL,CAAYxJ,IAAI,CAAC2J,IAAjB,EAAuBF,aAAvB,CAAP;AACD,KANM,MAMA,IAAItL,WAAW,CAAC6B,IAAD,CAAf,EAAuB;AAC5B,WAAK,MAAM4J,MAAX,IAAqB5J,IAAI,CAAC2J,IAA1B,EAAgC;AAC9B,YAAI,CAAC,KAAKH,MAAL,CAAYI,MAAZ,EAAoBH,aAApB,CAAL,EAAyC,OAAO,KAAP;AAC1C;;AAED,aAAO,IAAP;AACD,KANM,MAMA,IAAIxL,QAAQ,CAAC+B,IAAD,CAAZ,EAAoB;AACzB,aAAO,KAAKwJ,MAAL,CAAYxJ,IAAI,CAACiB,IAAjB,EAAuBwI,aAAvB,KAAyC,KAAKD,MAAL,CAAYxJ,IAAI,CAAC6J,KAAjB,EAAwBJ,aAAxB,CAAhD;AACD,KAFM,MAEA,IAAIzL,iBAAiB,CAACgC,IAAD,CAArB,EAA6B;AAClC,WAAK,MAAM8J,IAAX,IAAmB9J,IAAI,CAAC+J,QAAxB,EAAkC;AAChC,YAAI,CAAC,KAAKP,MAAL,CAAYM,IAAZ,EAAkBL,aAAlB,CAAL,EAAuC,OAAO,KAAP;AACxC;;AAED,aAAO,IAAP;AACD,KANM,MAMA,IAAI1K,kBAAkB,CAACiB,IAAD,CAAtB,EAA8B;AACnC,WAAK,MAAMgK,IAAX,IAAmBhK,IAAI,CAACc,UAAxB,EAAoC;AAClC,YAAI,CAAC,KAAK0I,MAAL,CAAYQ,IAAZ,EAAkBP,aAAlB,CAAL,EAAuC,OAAO,KAAP;AACxC;;AAED,aAAO,IAAP;AACD,KANM,MAMA,IAAI7K,QAAQ,CAACoB,IAAD,CAAZ,EAAoB;AACzB,UAAIA,IAAI,CAACiK,QAAL,IAAiB,CAAC,KAAKT,MAAL,CAAYxJ,IAAI,CAACgB,GAAjB,EAAsByI,aAAtB,CAAtB,EAA4D,OAAO,KAAP;AAC5D,UAAIzJ,IAAI,CAACiH,IAAL,KAAc,KAAd,IAAuBjH,IAAI,CAACiH,IAAL,KAAc,KAAzC,EAAgD,OAAO,KAAP;AAChD,aAAO,IAAP;AACD,KAJM,MAIA,IAAIjI,UAAU,CAACgB,IAAD,CAAd,EAAsB;AAC3B,UAAIA,IAAI,CAACiK,QAAL,IAAiB,CAAC,KAAKT,MAAL,CAAYxJ,IAAI,CAACgB,GAAjB,EAAsByI,aAAtB,CAAtB,EAA4D,OAAO,KAAP;AAC5D,aAAO,KAAKD,MAAL,CAAYxJ,IAAI,CAAC9C,KAAjB,EAAwBuM,aAAxB,CAAP;AACD,KAHM,MAGA,IAAInK,iBAAiB,CAACU,IAAD,CAArB,EAA6B;AAClC,aAAO,KAAKwJ,MAAL,CAAYxJ,IAAI,CAACe,QAAjB,EAA2B0I,aAA3B,CAAP;AACD,KAFM,MAEA,IAAItK,0BAA0B,CAACa,IAAD,CAA9B,EAAsC;AAC3C,aAAOR,cAAc,CAACQ,IAAI,CAACkK,GAAN,EAAW,YAAX,CAAd,IAA0C,CAAC,KAAK/D,UAAL,CAAgB,QAAhB,EAA0B,IAA1B,CAA3C,IAA8E,KAAKqD,MAAL,CAAYxJ,IAAI,CAACmK,KAAjB,EAAwBV,aAAxB,CAArF;AACD,KAFM,MAEA,IAAIrK,iBAAiB,CAACY,IAAD,CAArB,EAA6B;AAClC,WAAK,MAAMmB,UAAX,IAAyBnB,IAAI,CAACoK,WAA9B,EAA2C;AACzC,YAAI,CAAC,KAAKZ,MAAL,CAAYrI,UAAZ,EAAwBsI,aAAxB,CAAL,EAA6C,OAAO,KAAP;AAC9C;;AAED,aAAO,IAAP;AACD,KANM,MAMA;AACL,aAAOxK,SAAS,CAACe,IAAD,CAAhB;AACD;AACF;;AAEDqK,EAAAA,OAAO,CAACrJ,GAAD,EAAMsJ,GAAN,EAAW;AAChB,WAAO,KAAKvF,IAAL,CAAU/D,GAAV,IAAiBsJ,GAAxB;AACD;;AAEDC,EAAAA,OAAO,CAACvJ,GAAD,EAAM;AACX,QAAIc,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,YAAMiD,IAAI,GAAGjD,KAAK,CAACiD,IAAN,CAAW/D,GAAX,CAAb;AACA,UAAI+D,IAAI,IAAI,IAAZ,EAAkB,OAAOA,IAAP;AACnB,KAHD,QAGSjD,KAAK,GAAGA,KAAK,CAACQ,MAHvB;AAID;;AAEDkI,EAAAA,UAAU,CAACxJ,GAAD,EAAM;AACd,QAAIc,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,YAAMiD,IAAI,GAAGjD,KAAK,CAACiD,IAAN,CAAW/D,GAAX,CAAb;AACA,UAAI+D,IAAI,IAAI,IAAZ,EAAkBjD,KAAK,CAACiD,IAAN,CAAW/D,GAAX,IAAkB,IAAlB;AACnB,KAHD,QAGSc,KAAK,GAAGA,KAAK,CAACQ,MAHvB;AAID;;AAEDmI,EAAAA,IAAI,GAAG;AACL,QAAI,CAAC,KAAK7F,MAAV,EAAkB;AAChB,WAAKA,MAAL,GAAc,IAAd;AACA,WAAK8F,KAAL;AACD;AACF;;AAEDA,EAAAA,KAAK,GAAG;AACN,UAAMhJ,IAAI,GAAG,KAAKA,IAAlB;AACA,SAAKkB,UAAL,GAAkB7F,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAlB;AACA,SAAK5G,QAAL,GAAgBhH,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAhB;AACA,SAAK9F,OAAL,GAAe9H,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAf;AACA,SAAK7F,IAAL,GAAY/H,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAZ;AACA,SAAK5F,IAAL,GAAYhI,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAZ;AACA,UAAMC,aAAa,GAAG,KAAK3I,gBAAL,EAAtB;AACA,QAAI2I,aAAa,CAAC5F,QAAlB,EAA4B;AAC5B,UAAMrC,KAAK,GAAG;AACZC,MAAAA,UAAU,EAAE,EADA;AAEZG,MAAAA,kBAAkB,EAAE,EAFR;AAGZW,MAAAA,WAAW,EAAE;AAHD,KAAd;AAKA,SAAKsB,QAAL,GAAgB,IAAhB;;AAEA,QAAItD,IAAI,CAACxB,IAAL,KAAc,SAAd,IAA2BsB,gBAAgB,CAACqJ,SAAhD,EAA2D;AACzD,WAAK,MAAMC,KAAX,IAAoBtJ,gBAAgB,CAACuJ,KAArC,EAA4C;AAC1CD,QAAAA,KAAK,CAACpJ,IAAD,EAAOiB,KAAP,CAAL;AACD;;AAED,YAAMqI,YAAY,GAAGxJ,gBAAgB,CAACE,IAAI,CAACxB,IAAN,CAArC;;AAEA,UAAI8K,YAAJ,EAAkB;AAChB,aAAK,MAAMF,KAAX,IAAoBE,YAAY,CAACD,KAAjC,EAAwC;AACtCD,UAAAA,KAAK,CAACpJ,IAAD,EAAOiB,KAAP,CAAL;AACD;AACF;AACF;;AAEDjB,IAAAA,IAAI,CAACgE,QAAL,CAAclE,gBAAd,EAAgCmB,KAAhC;AACA,SAAKqC,QAAL,GAAgB,KAAhB;;AAEA,SAAK,MAAMtD,IAAX,IAAmBiB,KAAK,CAACe,WAAzB,EAAsC;AACpC,YAAMqF,GAAG,GAAGrH,IAAI,CAAC5D,qBAAL,EAAZ;;AAEA,WAAK,MAAM8C,IAAX,IAAmB7D,MAAM,CAACwG,IAAP,CAAYwF,GAAZ,CAAnB,EAAqC;AACnC,YAAIrH,IAAI,CAACI,KAAL,CAAWqB,UAAX,CAAsBvC,IAAtB,CAAJ,EAAiC;AACjCgK,QAAAA,aAAa,CAACtB,SAAd,CAAwBP,GAAG,CAACnI,IAAD,CAA3B;AACD;;AAEDc,MAAAA,IAAI,CAACI,KAAL,CAAWgH,yBAAX,CAAqCpH,IAArC;AACD;;AAED,SAAK,MAAMuJ,GAAX,IAAkBtI,KAAK,CAACC,UAAxB,EAAoC;AAClC,YAAMM,OAAO,GAAG+H,GAAG,CAACnJ,KAAJ,CAAUqB,UAAV,CAAqB8H,GAAG,CAACjL,IAAJ,CAASY,IAA9B,CAAhB;;AAEA,UAAIsC,OAAJ,EAAa;AACXA,QAAAA,OAAO,CAACE,SAAR,CAAkB6H,GAAlB;AACD,OAFD,MAEO;AACLL,QAAAA,aAAa,CAACtB,SAAd,CAAwB2B,GAAG,CAACjL,IAA5B;AACD;AACF;;AAED,SAAK,MAAM0B,IAAX,IAAmBiB,KAAK,CAACI,kBAAzB,EAA6C;AAC3CrB,MAAAA,IAAI,CAACI,KAAL,CAAWgH,yBAAX,CAAqCpH,IAArC;AACD;AACF;;AAEDjB,EAAAA,IAAI,CAACkF,IAAD,EAAO;AACT,QAAIjE,IAAI,GAAG,KAAKA,IAAhB;;AAEA,QAAI,CAACA,IAAI,CAACwJ,gBAAL,EAAD,IAA4B,CAACxJ,IAAI,CAACyJ,SAAL,EAAjC,EAAmD;AACjDzJ,MAAAA,IAAI,GAAG,KAAKe,cAAL,GAAsBf,IAA7B;AACD;;AAED,QAAIA,IAAI,CAAC0J,iBAAL,EAAJ,EAA8B;AAC5B1J,MAAAA,IAAI,GAAG,CAAC,KAAKM,iBAAL,MAA4B,KAAKC,gBAAL,EAA7B,EAAsDP,IAA7D;AACD;;AAED,QAAIA,IAAI,CAAC2J,MAAL,MAAiB3J,IAAI,CAAC4J,aAAL,EAAjB,IAAyC5J,IAAI,CAAC6J,UAAL,EAA7C,EAAgE;AAC9D7J,MAAAA,IAAI,CAAC8J,WAAL;AACA9J,MAAAA,IAAI,GAAGA,IAAI,CAACE,GAAL,CAAS,MAAT,CAAP;AACD;;AAED,UAAM6J,MAAM,GAAG9F,IAAI,CAAC8F,MAApB;AACA,UAAMxE,IAAI,GAAGtB,IAAI,CAACsB,IAAL,IAAa,KAA1B;AACA,UAAMyE,UAAU,GAAG/F,IAAI,CAACgG,WAAL,IAAoB,IAApB,GAA2B,CAA3B,GAA+BhG,IAAI,CAACgG,WAAvD;AACA,UAAMC,OAAO,GAAI,eAAc3E,IAAK,IAAGyE,UAAW,EAAlD;AACA,QAAIG,UAAU,GAAG,CAACJ,MAAD,IAAW/J,IAAI,CAAC6I,OAAL,CAAaqB,OAAb,CAA5B;;AAEA,QAAI,CAACC,UAAL,EAAiB;AACf,YAAMlK,MAAM,GAAG9B,mBAAmB,CAACoH,IAAD,EAAO,EAAP,CAAlC;AACAtF,MAAAA,MAAM,CAACgK,WAAP,GAAqBD,UAArB;AACA,OAACG,UAAD,IAAenK,IAAI,CAACoK,gBAAL,CAAsB,MAAtB,EAA8B,CAACnK,MAAD,CAA9B,CAAf;AACA,UAAI,CAAC8J,MAAL,EAAa/J,IAAI,CAAC2I,OAAL,CAAauB,OAAb,EAAsBC,UAAtB;AACd;;AAED,UAAME,UAAU,GAAGjM,kBAAkB,CAAC6F,IAAI,CAACzE,EAAN,EAAUyE,IAAI,CAAC8E,IAAf,CAArC;AACAoB,IAAAA,UAAU,CAAC7L,IAAX,CAAgBsD,YAAhB,CAA6B7C,IAA7B,CAAkCsL,UAAlC;AACA,SAAK7J,eAAL,CAAqB+E,IAArB,EAA2B4E,UAAU,CAACjK,GAAX,CAAe,cAAf,EAA+BoK,GAA/B,EAA3B;AACD;;AAED/J,EAAAA,gBAAgB,GAAG;AACjB,QAAIH,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,UAAIA,KAAK,CAACJ,IAAN,CAAWyJ,SAAX,EAAJ,EAA4B;AAC1B,eAAOrJ,KAAP;AACD;AACF,KAJD,QAISA,KAAK,GAAGA,KAAK,CAACQ,MAJvB;;AAMA,UAAM,IAAI2J,KAAJ,CAAU,yBAAV,CAAN;AACD;;AAEDjK,EAAAA,iBAAiB,GAAG;AAClB,QAAIF,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,UAAIA,KAAK,CAACJ,IAAN,CAAWwK,gBAAX,EAAJ,EAAmC;AACjC,eAAOpK,KAAP;AACD;AACF,KAJD,QAISA,KAAK,GAAGA,KAAK,CAACQ,MAJvB;;AAMA,WAAO,IAAP;AACD;;AAEDG,EAAAA,cAAc,GAAG;AACf,QAAIX,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,UAAIA,KAAK,CAACJ,IAAN,CAAWyK,aAAX,EAAJ,EAAgC;AAC9B,eAAOrK,KAAP;AACD;AACF,KAJD,QAISA,KAAK,GAAGA,KAAK,CAACQ,MAJvB;;AAMA,UAAM,IAAI2J,KAAJ,CAAU,8EAAV,CAAN;AACD;;AAEDG,EAAAA,cAAc,GAAG;AACf,UAAMrD,GAAG,GAAGhM,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAZ;AACA,QAAI7I,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,WAAK,MAAMd,GAAX,IAAkBjE,MAAM,CAACwG,IAAP,CAAYzB,KAAK,CAACiC,QAAlB,CAAlB,EAA+C;AAC7C,YAAI/C,GAAG,IAAI+H,GAAP,KAAe,KAAnB,EAA0B;AACxBA,UAAAA,GAAG,CAAC/H,GAAD,CAAH,GAAWc,KAAK,CAACiC,QAAN,CAAe/C,GAAf,CAAX;AACD;AACF;;AAEDc,MAAAA,KAAK,GAAGA,KAAK,CAACQ,MAAd;AACD,KARD,QAQSR,KART;;AAUA,WAAOiH,GAAP;AACD;;AAEDsD,EAAAA,oBAAoB,GAAW;AAC7B,UAAMtD,GAAG,GAAGhM,MAAM,CAAC4N,MAAP,CAAc,IAAd,CAAZ;;AAD6B,sCAAP2B,KAAO;AAAPA,MAAAA,KAAO;AAAA;;AAG7B,SAAK,MAAMrF,IAAX,IAAmBqF,KAAnB,EAA0B;AACxB,UAAIxK,KAAK,GAAG,IAAZ;;AAEA,SAAG;AACD,aAAK,MAAMlB,IAAX,IAAmB7D,MAAM,CAACwG,IAAP,CAAYzB,KAAK,CAACiC,QAAlB,CAAnB,EAAgD;AAC9C,gBAAMb,OAAO,GAAGpB,KAAK,CAACiC,QAAN,CAAenD,IAAf,CAAhB;AACA,cAAIsC,OAAO,CAAC+D,IAAR,KAAiBA,IAArB,EAA2B8B,GAAG,CAACnI,IAAD,CAAH,GAAYsC,OAAZ;AAC5B;;AAEDpB,QAAAA,KAAK,GAAGA,KAAK,CAACQ,MAAd;AACD,OAPD,QAOSR,KAPT;AAQD;;AAED,WAAOiH,GAAP;AACD;;AAEDwD,EAAAA,uBAAuB,CAAC3L,IAAD,EAAOZ,IAAP,EAAa;AAClC,WAAO,KAAKwM,oBAAL,CAA0B5L,IAA1B,MAAoCZ,IAA3C;AACD;;AAEDmD,EAAAA,UAAU,CAACvC,IAAD,EAAO;AACf,QAAIkB,KAAK,GAAG,IAAZ;AACA,QAAI2K,YAAJ;;AAEA,OAAG;AACD,YAAMvJ,OAAO,GAAGpB,KAAK,CAACuH,aAAN,CAAoBzI,IAApB,CAAhB;;AAEA,UAAIsC,OAAJ,EAAa;AACX,YAAIwJ,aAAJ;;AAEA,YAAI,CAACA,aAAa,GAAGD,YAAjB,KAAkC,IAAlC,IAA0CC,aAAa,CAAC5J,SAAd,EAA1C,IAAuEI,OAAO,CAAC+D,IAAR,KAAiB,OAAxF,IAAmG/D,OAAO,CAAC+D,IAAR,KAAiB,OAAxH,EAAiI,CAAE,CAAnI,MAAyI;AACvI,iBAAO/D,OAAP;AACD;AACF,OAND,MAMO,IAAI,CAACA,OAAD,IAAYtC,IAAI,KAAK,WAArB,IAAoCkB,KAAK,CAACJ,IAAN,CAAW6J,UAAX,EAApC,IAA+D,CAACzJ,KAAK,CAACJ,IAAN,CAAWiL,yBAAX,EAApE,EAA4G;AACjH;AACD;;AAEDF,MAAAA,YAAY,GAAG3K,KAAK,CAACJ,IAArB;AACD,KAdD,QAcSI,KAAK,GAAGA,KAAK,CAACQ,MAdvB;AAeD;;AAED+G,EAAAA,aAAa,CAACzI,IAAD,EAAO;AAClB,WAAO,KAAKmD,QAAL,CAAcnD,IAAd,CAAP;AACD;;AAED4L,EAAAA,oBAAoB,CAAC5L,IAAD,EAAO;AACzB,QAAIgM,gBAAJ;;AAEA,WAAO,CAACA,gBAAgB,GAAG,KAAKzJ,UAAL,CAAgBvC,IAAhB,CAApB,KAA8C,IAA9C,GAAqD,KAAK,CAA1D,GAA8DgM,gBAAgB,CAAC7O,UAAtF;AACD;;AAED8O,EAAAA,uBAAuB,CAACjM,IAAD,EAAO;AAC5B,UAAMsC,OAAO,GAAG,KAAKa,QAAL,CAAcnD,IAAd,CAAhB;AACA,WAAOsC,OAAO,IAAI,IAAX,GAAkB,KAAK,CAAvB,GAA2BA,OAAO,CAACnF,UAA1C;AACD;;AAED+O,EAAAA,aAAa,CAAClM,IAAD,EAAO;AAClB,WAAO,CAAC,CAAC,KAAKyI,aAAL,CAAmBzI,IAAnB,CAAT;AACD;;AAEDuF,EAAAA,UAAU,CAACvF,IAAD,EAAOmM,SAAP,EAAkB;AAC1B,QAAI,CAACnM,IAAL,EAAW,OAAO,KAAP;AACX,QAAI,KAAKkM,aAAL,CAAmBlM,IAAnB,CAAJ,EAA8B,OAAO,IAAP;AAC9B,QAAI,KAAKoM,gBAAL,CAAsBpM,IAAtB,EAA4BmM,SAA5B,CAAJ,EAA4C,OAAO,IAAP;AAC5C,QAAI,KAAKxD,MAAL,CAAY3I,IAAZ,CAAJ,EAAuB,OAAO,IAAP;AACvB,QAAI,CAACmM,SAAD,IAAcvI,KAAK,CAACK,OAAN,CAAcoI,QAAd,CAAuBrM,IAAvB,CAAlB,EAAgD,OAAO,IAAP;AAChD,QAAI,CAACmM,SAAD,IAAcvI,KAAK,CAAC0I,gBAAN,CAAuBD,QAAvB,CAAgCrM,IAAhC,CAAlB,EAAyD,OAAO,IAAP;AACzD,WAAO,KAAP;AACD;;AAEDoM,EAAAA,gBAAgB,CAACpM,IAAD,EAAOmM,SAAP,EAAkB;AAChC,QAAII,YAAJ;;AAEA,WAAO,CAACA,YAAY,GAAG,KAAK7K,MAArB,KAAgC,IAAhC,GAAuC,KAAK,CAA5C,GAAgD6K,YAAY,CAAChH,UAAb,CAAwBvF,IAAxB,EAA8BmM,SAA9B,CAAvD;AACD;;AAEDK,EAAAA,aAAa,CAACxM,IAAD,EAAOkB,KAAP,EAAc;AACzB,UAAMuL,IAAI,GAAG,KAAKlK,UAAL,CAAgBvC,IAAhB,CAAb;;AAEA,QAAIyM,IAAJ,EAAU;AACRA,MAAAA,IAAI,CAACvL,KAAL,CAAWwL,gBAAX,CAA4B1M,IAA5B;AACAyM,MAAAA,IAAI,CAACvL,KAAL,GAAaA,KAAb;AACAA,MAAAA,KAAK,CAACiC,QAAN,CAAenD,IAAf,IAAuByM,IAAvB;AACD;AACF;;AAEDC,EAAAA,gBAAgB,CAAC1M,IAAD,EAAO;AACrB,WAAO,KAAKmD,QAAL,CAAcnD,IAAd,CAAP;AACD;;AAED2M,EAAAA,aAAa,CAAC3M,IAAD,EAAO;AAClB,QAAI4M,iBAAJ;;AAEA,KAACA,iBAAiB,GAAG,KAAKrK,UAAL,CAAgBvC,IAAhB,CAArB,KAA+C,IAA/C,GAAsD,KAAK,CAA3D,GAA+D4M,iBAAiB,CAAC1L,KAAlB,CAAwBwL,gBAAxB,CAAyC1M,IAAzC,CAA/D;AACA,QAAIkB,KAAK,GAAG,IAAZ;;AAEA,OAAG;AACD,UAAIA,KAAK,CAACgD,IAAN,CAAWlE,IAAX,CAAJ,EAAsB;AACpBkB,QAAAA,KAAK,CAACgD,IAAN,CAAWlE,IAAX,IAAmB,KAAnB;AACD;AACF,KAJD,QAISkB,KAAK,GAAGA,KAAK,CAACQ,MAJvB;AAKD;;AA9qBS;;AAkrBZrF,OAAO,CAACE,OAAR,GAAkBqH,KAAlB;AACAA,KAAK,CAACK,OAAN,GAAgB9H,MAAM,CAACwG,IAAP,CAAY/F,QAAQ,CAACiQ,OAArB,CAAhB;AACAjJ,KAAK,CAAC0I,gBAAN,GAAyB,CAAC,WAAD,EAAc,WAAd,EAA2B,UAA3B,EAAuC,KAAvC,CAAzB","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _renamer = require(\"./lib/renamer\");\n\nvar _index = require(\"../index\");\n\nvar _binding = require(\"./binding\");\n\nvar _globals = require(\"globals\");\n\nvar _t = require(\"@babel/types\");\n\nvar _cache = require(\"../cache\");\n\nconst {\n  NOT_LOCAL_BINDING,\n  callExpression,\n  cloneNode,\n  getBindingIdentifiers,\n  identifier,\n  isArrayExpression,\n  isBinary,\n  isClass,\n  isClassBody,\n  isClassDeclaration,\n  isExportAllDeclaration,\n  isExportDefaultDeclaration,\n  isExportNamedDeclaration,\n  isFunctionDeclaration,\n  isIdentifier,\n  isImportDeclaration,\n  isLiteral,\n  isMethod,\n  isModuleDeclaration,\n  isModuleSpecifier,\n  isObjectExpression,\n  isProperty,\n  isPureish,\n  isSuper,\n  isTaggedTemplateExpression,\n  isTemplateLiteral,\n  isThisExpression,\n  isUnaryExpression,\n  isVariableDeclaration,\n  matchesPattern,\n  memberExpression,\n  numericLiteral,\n  toIdentifier,\n  unaryExpression,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction gatherNodeParts(node, parts) {\n  switch (node == null ? void 0 : node.type) {\n    default:\n      if (isModuleDeclaration(node)) {\n        if ((isExportAllDeclaration(node) || isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.source) {\n          gatherNodeParts(node.source, parts);\n        } else if ((isExportNamedDeclaration(node) || isImportDeclaration(node)) && node.specifiers && node.specifiers.length) {\n          for (const e of node.specifiers) gatherNodeParts(e, parts);\n        } else if ((isExportDefaultDeclaration(node) || isExportNamedDeclaration(node)) && node.declaration) {\n          gatherNodeParts(node.declaration, parts);\n        }\n      } else if (isModuleSpecifier(node)) {\n        gatherNodeParts(node.local, parts);\n      } else if (isLiteral(node)) {\n        parts.push(node.value);\n      }\n\n      break;\n\n    case \"MemberExpression\":\n    case \"OptionalMemberExpression\":\n    case \"JSXMemberExpression\":\n      gatherNodeParts(node.object, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"Identifier\":\n    case \"JSXIdentifier\":\n      parts.push(node.name);\n      break;\n\n    case \"CallExpression\":\n    case \"OptionalCallExpression\":\n    case \"NewExpression\":\n      gatherNodeParts(node.callee, parts);\n      break;\n\n    case \"ObjectExpression\":\n    case \"ObjectPattern\":\n      for (const e of node.properties) {\n        gatherNodeParts(e, parts);\n      }\n\n      break;\n\n    case \"SpreadElement\":\n    case \"RestElement\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"ObjectProperty\":\n    case \"ObjectMethod\":\n    case \"ClassProperty\":\n    case \"ClassMethod\":\n    case \"ClassPrivateProperty\":\n    case \"ClassPrivateMethod\":\n      gatherNodeParts(node.key, parts);\n      break;\n\n    case \"ThisExpression\":\n      parts.push(\"this\");\n      break;\n\n    case \"Super\":\n      parts.push(\"super\");\n      break;\n\n    case \"Import\":\n      parts.push(\"import\");\n      break;\n\n    case \"DoExpression\":\n      parts.push(\"do\");\n      break;\n\n    case \"YieldExpression\":\n      parts.push(\"yield\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AwaitExpression\":\n      parts.push(\"await\");\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"AssignmentExpression\":\n      gatherNodeParts(node.left, parts);\n      break;\n\n    case \"VariableDeclarator\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"FunctionExpression\":\n    case \"FunctionDeclaration\":\n    case \"ClassExpression\":\n    case \"ClassDeclaration\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"PrivateName\":\n      gatherNodeParts(node.id, parts);\n      break;\n\n    case \"ParenthesizedExpression\":\n      gatherNodeParts(node.expression, parts);\n      break;\n\n    case \"UnaryExpression\":\n    case \"UpdateExpression\":\n      gatherNodeParts(node.argument, parts);\n      break;\n\n    case \"MetaProperty\":\n      gatherNodeParts(node.meta, parts);\n      gatherNodeParts(node.property, parts);\n      break;\n\n    case \"JSXElement\":\n      gatherNodeParts(node.openingElement, parts);\n      break;\n\n    case \"JSXOpeningElement\":\n      parts.push(node.name);\n      break;\n\n    case \"JSXFragment\":\n      gatherNodeParts(node.openingFragment, parts);\n      break;\n\n    case \"JSXOpeningFragment\":\n      parts.push(\"Fragment\");\n      break;\n\n    case \"JSXNamespacedName\":\n      gatherNodeParts(node.namespace, parts);\n      gatherNodeParts(node.name, parts);\n      break;\n  }\n}\n\nconst collectorVisitor = {\n  ForStatement(path) {\n    const declar = path.get(\"init\");\n\n    if (declar.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", declar);\n    }\n  },\n\n  Declaration(path) {\n    if (path.isBlockScoped()) return;\n    if (path.isImportDeclaration()) return;\n    if (path.isExportDeclaration()) return;\n    const parent = path.scope.getFunctionParent() || path.scope.getProgramParent();\n    parent.registerDeclaration(path);\n  },\n\n  ImportDeclaration(path) {\n    const parent = path.scope.getBlockParent();\n    parent.registerDeclaration(path);\n  },\n\n  ReferencedIdentifier(path, state) {\n    state.references.push(path);\n  },\n\n  ForXStatement(path, state) {\n    const left = path.get(\"left\");\n\n    if (left.isPattern() || left.isIdentifier()) {\n      state.constantViolations.push(path);\n    } else if (left.isVar()) {\n      const {\n        scope\n      } = path;\n      const parentScope = scope.getFunctionParent() || scope.getProgramParent();\n      parentScope.registerBinding(\"var\", left);\n    }\n  },\n\n  ExportDeclaration: {\n    exit(path) {\n      const {\n        node,\n        scope\n      } = path;\n      if (isExportAllDeclaration(node)) return;\n      const declar = node.declaration;\n\n      if (isClassDeclaration(declar) || isFunctionDeclaration(declar)) {\n        const id = declar.id;\n        if (!id) return;\n        const binding = scope.getBinding(id.name);\n        binding == null ? void 0 : binding.reference(path);\n      } else if (isVariableDeclaration(declar)) {\n        for (const decl of declar.declarations) {\n          for (const name of Object.keys(getBindingIdentifiers(decl))) {\n            const binding = scope.getBinding(name);\n            binding == null ? void 0 : binding.reference(path);\n          }\n        }\n      }\n    }\n\n  },\n\n  LabeledStatement(path) {\n    path.scope.getBlockParent().registerDeclaration(path);\n  },\n\n  AssignmentExpression(path, state) {\n    state.assignments.push(path);\n  },\n\n  UpdateExpression(path, state) {\n    state.constantViolations.push(path);\n  },\n\n  UnaryExpression(path, state) {\n    if (path.node.operator === \"delete\") {\n      state.constantViolations.push(path);\n    }\n  },\n\n  BlockScoped(path) {\n    let scope = path.scope;\n    if (scope.path === path) scope = scope.parent;\n    const parent = scope.getBlockParent();\n    parent.registerDeclaration(path);\n\n    if (path.isClassDeclaration() && path.node.id) {\n      const id = path.node.id;\n      const name = id.name;\n      path.scope.bindings[name] = path.scope.parent.getBinding(name);\n    }\n  },\n\n  CatchClause(path) {\n    path.scope.registerBinding(\"let\", path);\n  },\n\n  Function(path) {\n    const params = path.get(\"params\");\n\n    for (const param of params) {\n      path.scope.registerBinding(\"param\", param);\n    }\n\n    if (path.isFunctionExpression() && path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path.get(\"id\"), path);\n    }\n  },\n\n  ClassExpression(path) {\n    if (path.has(\"id\") && !path.get(\"id\").node[NOT_LOCAL_BINDING]) {\n      path.scope.registerBinding(\"local\", path);\n    }\n  }\n\n};\nlet uid = 0;\n\nclass Scope {\n  constructor(path) {\n    this.uid = void 0;\n    this.path = void 0;\n    this.block = void 0;\n    this.labels = void 0;\n    this.inited = void 0;\n    this.bindings = void 0;\n    this.references = void 0;\n    this.globals = void 0;\n    this.uids = void 0;\n    this.data = void 0;\n    this.crawling = void 0;\n    const {\n      node\n    } = path;\n\n    const cached = _cache.scope.get(node);\n\n    if ((cached == null ? void 0 : cached.path) === path) {\n      return cached;\n    }\n\n    _cache.scope.set(node, this);\n\n    this.uid = uid++;\n    this.block = node;\n    this.path = path;\n    this.labels = new Map();\n    this.inited = false;\n  }\n\n  get parent() {\n    var _parent;\n\n    let parent,\n        path = this.path;\n\n    do {\n      const isKey = path.key === \"key\";\n      path = path.parentPath;\n      if (isKey && path.isMethod()) path = path.parentPath;\n      if (path && path.isScope()) parent = path;\n    } while (path && !parent);\n\n    return (_parent = parent) == null ? void 0 : _parent.scope;\n  }\n\n  get parentBlock() {\n    return this.path.parent;\n  }\n\n  get hub() {\n    return this.path.hub;\n  }\n\n  traverse(node, opts, state) {\n    (0, _index.default)(node, opts, this, state, this.path);\n  }\n\n  generateDeclaredUidIdentifier(name) {\n    const id = this.generateUidIdentifier(name);\n    this.push({\n      id\n    });\n    return cloneNode(id);\n  }\n\n  generateUidIdentifier(name) {\n    return identifier(this.generateUid(name));\n  }\n\n  generateUid(name = \"temp\") {\n    name = toIdentifier(name).replace(/^_+/, \"\").replace(/[0-9]+$/g, \"\");\n    let uid;\n    let i = 1;\n\n    do {\n      uid = this._generateUid(name, i);\n      i++;\n    } while (this.hasLabel(uid) || this.hasBinding(uid) || this.hasGlobal(uid) || this.hasReference(uid));\n\n    const program = this.getProgramParent();\n    program.references[uid] = true;\n    program.uids[uid] = true;\n    return uid;\n  }\n\n  _generateUid(name, i) {\n    let id = name;\n    if (i > 1) id += i;\n    return `_${id}`;\n  }\n\n  generateUidBasedOnNode(node, defaultName) {\n    const parts = [];\n    gatherNodeParts(node, parts);\n    let id = parts.join(\"$\");\n    id = id.replace(/^_/, \"\") || defaultName || \"ref\";\n    return this.generateUid(id.slice(0, 20));\n  }\n\n  generateUidIdentifierBasedOnNode(node, defaultName) {\n    return identifier(this.generateUidBasedOnNode(node, defaultName));\n  }\n\n  isStatic(node) {\n    if (isThisExpression(node) || isSuper(node)) {\n      return true;\n    }\n\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding) {\n        return binding.constant;\n      } else {\n        return this.hasBinding(node.name);\n      }\n    }\n\n    return false;\n  }\n\n  maybeGenerateMemoised(node, dontPush) {\n    if (this.isStatic(node)) {\n      return null;\n    } else {\n      const id = this.generateUidIdentifierBasedOnNode(node);\n\n      if (!dontPush) {\n        this.push({\n          id\n        });\n        return cloneNode(id);\n      }\n\n      return id;\n    }\n  }\n\n  checkBlockScopedCollisions(local, kind, name, id) {\n    if (kind === \"param\") return;\n    if (local.kind === \"local\") return;\n    const duplicate = kind === \"let\" || local.kind === \"let\" || local.kind === \"const\" || local.kind === \"module\" || local.kind === \"param\" && (kind === \"let\" || kind === \"const\");\n\n    if (duplicate) {\n      throw this.hub.buildError(id, `Duplicate declaration \"${name}\"`, TypeError);\n    }\n  }\n\n  rename(oldName, newName, block) {\n    const binding = this.getBinding(oldName);\n\n    if (binding) {\n      newName = newName || this.generateUidIdentifier(oldName).name;\n      return new _renamer.default(binding, oldName, newName).rename(block);\n    }\n  }\n\n  _renameFromMap(map, oldName, newName, value) {\n    if (map[oldName]) {\n      map[newName] = value;\n      map[oldName] = null;\n    }\n  }\n\n  dump() {\n    const sep = \"-\".repeat(60);\n    console.log(sep);\n    let scope = this;\n\n    do {\n      console.log(\"#\", scope.block.type);\n\n      for (const name of Object.keys(scope.bindings)) {\n        const binding = scope.bindings[name];\n        console.log(\" -\", name, {\n          constant: binding.constant,\n          references: binding.references,\n          violations: binding.constantViolations.length,\n          kind: binding.kind\n        });\n      }\n    } while (scope = scope.parent);\n\n    console.log(sep);\n  }\n\n  toArray(node, i, arrayLikeIsIterable) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n\n      if (binding != null && binding.constant && binding.path.isGenericType(\"Array\")) {\n        return node;\n      }\n    }\n\n    if (isArrayExpression(node)) {\n      return node;\n    }\n\n    if (isIdentifier(node, {\n      name: \"arguments\"\n    })) {\n      return callExpression(memberExpression(memberExpression(memberExpression(identifier(\"Array\"), identifier(\"prototype\")), identifier(\"slice\")), identifier(\"call\")), [node]);\n    }\n\n    let helperName;\n    const args = [node];\n\n    if (i === true) {\n      helperName = \"toConsumableArray\";\n    } else if (i) {\n      args.push(numericLiteral(i));\n      helperName = \"slicedToArray\";\n    } else {\n      helperName = \"toArray\";\n    }\n\n    if (arrayLikeIsIterable) {\n      args.unshift(this.hub.addHelper(helperName));\n      helperName = \"maybeArrayLike\";\n    }\n\n    return callExpression(this.hub.addHelper(helperName), args);\n  }\n\n  hasLabel(name) {\n    return !!this.getLabel(name);\n  }\n\n  getLabel(name) {\n    return this.labels.get(name);\n  }\n\n  registerLabel(path) {\n    this.labels.set(path.node.label.name, path);\n  }\n\n  registerDeclaration(path) {\n    if (path.isLabeledStatement()) {\n      this.registerLabel(path);\n    } else if (path.isFunctionDeclaration()) {\n      this.registerBinding(\"hoisted\", path.get(\"id\"), path);\n    } else if (path.isVariableDeclaration()) {\n      const declarations = path.get(\"declarations\");\n\n      for (const declar of declarations) {\n        this.registerBinding(path.node.kind, declar);\n      }\n    } else if (path.isClassDeclaration()) {\n      if (path.node.declare) return;\n      this.registerBinding(\"let\", path);\n    } else if (path.isImportDeclaration()) {\n      const specifiers = path.get(\"specifiers\");\n\n      for (const specifier of specifiers) {\n        this.registerBinding(\"module\", specifier);\n      }\n    } else if (path.isExportDeclaration()) {\n      const declar = path.get(\"declaration\");\n\n      if (declar.isClassDeclaration() || declar.isFunctionDeclaration() || declar.isVariableDeclaration()) {\n        this.registerDeclaration(declar);\n      }\n    } else {\n      this.registerBinding(\"unknown\", path);\n    }\n  }\n\n  buildUndefinedNode() {\n    return unaryExpression(\"void\", numericLiteral(0), true);\n  }\n\n  registerConstantViolation(path) {\n    const ids = path.getBindingIdentifiers();\n\n    for (const name of Object.keys(ids)) {\n      const binding = this.getBinding(name);\n      if (binding) binding.reassign(path);\n    }\n  }\n\n  registerBinding(kind, path, bindingPath = path) {\n    if (!kind) throw new ReferenceError(\"no `kind`\");\n\n    if (path.isVariableDeclaration()) {\n      const declarators = path.get(\"declarations\");\n\n      for (const declar of declarators) {\n        this.registerBinding(kind, declar);\n      }\n\n      return;\n    }\n\n    const parent = this.getProgramParent();\n    const ids = path.getOuterBindingIdentifiers(true);\n\n    for (const name of Object.keys(ids)) {\n      parent.references[name] = true;\n\n      for (const id of ids[name]) {\n        const local = this.getOwnBinding(name);\n\n        if (local) {\n          if (local.identifier === id) continue;\n          this.checkBlockScopedCollisions(local, kind, name, id);\n        }\n\n        if (local) {\n          this.registerConstantViolation(bindingPath);\n        } else {\n          this.bindings[name] = new _binding.default({\n            identifier: id,\n            scope: this,\n            path: bindingPath,\n            kind: kind\n          });\n        }\n      }\n    }\n  }\n\n  addGlobal(node) {\n    this.globals[node.name] = node;\n  }\n\n  hasUid(name) {\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasGlobal(name) {\n    let scope = this;\n\n    do {\n      if (scope.globals[name]) return true;\n    } while (scope = scope.parent);\n\n    return false;\n  }\n\n  hasReference(name) {\n    return !!this.getProgramParent().references[name];\n  }\n\n  isPure(node, constantsOnly) {\n    if (isIdentifier(node)) {\n      const binding = this.getBinding(node.name);\n      if (!binding) return false;\n      if (constantsOnly) return binding.constant;\n      return true;\n    } else if (isClass(node)) {\n      if (node.superClass && !this.isPure(node.superClass, constantsOnly)) {\n        return false;\n      }\n\n      return this.isPure(node.body, constantsOnly);\n    } else if (isClassBody(node)) {\n      for (const method of node.body) {\n        if (!this.isPure(method, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isBinary(node)) {\n      return this.isPure(node.left, constantsOnly) && this.isPure(node.right, constantsOnly);\n    } else if (isArrayExpression(node)) {\n      for (const elem of node.elements) {\n        if (!this.isPure(elem, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isObjectExpression(node)) {\n      for (const prop of node.properties) {\n        if (!this.isPure(prop, constantsOnly)) return false;\n      }\n\n      return true;\n    } else if (isMethod(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      if (node.kind === \"get\" || node.kind === \"set\") return false;\n      return true;\n    } else if (isProperty(node)) {\n      if (node.computed && !this.isPure(node.key, constantsOnly)) return false;\n      return this.isPure(node.value, constantsOnly);\n    } else if (isUnaryExpression(node)) {\n      return this.isPure(node.argument, constantsOnly);\n    } else if (isTaggedTemplateExpression(node)) {\n      return matchesPattern(node.tag, \"String.raw\") && !this.hasBinding(\"String\", true) && this.isPure(node.quasi, constantsOnly);\n    } else if (isTemplateLiteral(node)) {\n      for (const expression of node.expressions) {\n        if (!this.isPure(expression, constantsOnly)) return false;\n      }\n\n      return true;\n    } else {\n      return isPureish(node);\n    }\n  }\n\n  setData(key, val) {\n    return this.data[key] = val;\n  }\n\n  getData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) return data;\n    } while (scope = scope.parent);\n  }\n\n  removeData(key) {\n    let scope = this;\n\n    do {\n      const data = scope.data[key];\n      if (data != null) scope.data[key] = null;\n    } while (scope = scope.parent);\n  }\n\n  init() {\n    if (!this.inited) {\n      this.inited = true;\n      this.crawl();\n    }\n  }\n\n  crawl() {\n    const path = this.path;\n    this.references = Object.create(null);\n    this.bindings = Object.create(null);\n    this.globals = Object.create(null);\n    this.uids = Object.create(null);\n    this.data = Object.create(null);\n    const programParent = this.getProgramParent();\n    if (programParent.crawling) return;\n    const state = {\n      references: [],\n      constantViolations: [],\n      assignments: []\n    };\n    this.crawling = true;\n\n    if (path.type !== \"Program\" && collectorVisitor._exploded) {\n      for (const visit of collectorVisitor.enter) {\n        visit(path, state);\n      }\n\n      const typeVisitors = collectorVisitor[path.type];\n\n      if (typeVisitors) {\n        for (const visit of typeVisitors.enter) {\n          visit(path, state);\n        }\n      }\n    }\n\n    path.traverse(collectorVisitor, state);\n    this.crawling = false;\n\n    for (const path of state.assignments) {\n      const ids = path.getBindingIdentifiers();\n\n      for (const name of Object.keys(ids)) {\n        if (path.scope.getBinding(name)) continue;\n        programParent.addGlobal(ids[name]);\n      }\n\n      path.scope.registerConstantViolation(path);\n    }\n\n    for (const ref of state.references) {\n      const binding = ref.scope.getBinding(ref.node.name);\n\n      if (binding) {\n        binding.reference(ref);\n      } else {\n        programParent.addGlobal(ref.node);\n      }\n    }\n\n    for (const path of state.constantViolations) {\n      path.scope.registerConstantViolation(path);\n    }\n  }\n\n  push(opts) {\n    let path = this.path;\n\n    if (!path.isBlockStatement() && !path.isProgram()) {\n      path = this.getBlockParent().path;\n    }\n\n    if (path.isSwitchStatement()) {\n      path = (this.getFunctionParent() || this.getProgramParent()).path;\n    }\n\n    if (path.isLoop() || path.isCatchClause() || path.isFunction()) {\n      path.ensureBlock();\n      path = path.get(\"body\");\n    }\n\n    const unique = opts.unique;\n    const kind = opts.kind || \"var\";\n    const blockHoist = opts._blockHoist == null ? 2 : opts._blockHoist;\n    const dataKey = `declaration:${kind}:${blockHoist}`;\n    let declarPath = !unique && path.getData(dataKey);\n\n    if (!declarPath) {\n      const declar = variableDeclaration(kind, []);\n      declar._blockHoist = blockHoist;\n      [declarPath] = path.unshiftContainer(\"body\", [declar]);\n      if (!unique) path.setData(dataKey, declarPath);\n    }\n\n    const declarator = variableDeclarator(opts.id, opts.init);\n    declarPath.node.declarations.push(declarator);\n    this.registerBinding(kind, declarPath.get(\"declarations\").pop());\n  }\n\n  getProgramParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isProgram()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"Couldn't find a Program\");\n  }\n\n  getFunctionParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isFunctionParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    return null;\n  }\n\n  getBlockParent() {\n    let scope = this;\n\n    do {\n      if (scope.path.isBlockParent()) {\n        return scope;\n      }\n    } while (scope = scope.parent);\n\n    throw new Error(\"We couldn't find a BlockStatement, For, Switch, Function, Loop or Program...\");\n  }\n\n  getAllBindings() {\n    const ids = Object.create(null);\n    let scope = this;\n\n    do {\n      for (const key of Object.keys(scope.bindings)) {\n        if (key in ids === false) {\n          ids[key] = scope.bindings[key];\n        }\n      }\n\n      scope = scope.parent;\n    } while (scope);\n\n    return ids;\n  }\n\n  getAllBindingsOfKind(...kinds) {\n    const ids = Object.create(null);\n\n    for (const kind of kinds) {\n      let scope = this;\n\n      do {\n        for (const name of Object.keys(scope.bindings)) {\n          const binding = scope.bindings[name];\n          if (binding.kind === kind) ids[name] = binding;\n        }\n\n        scope = scope.parent;\n      } while (scope);\n    }\n\n    return ids;\n  }\n\n  bindingIdentifierEquals(name, node) {\n    return this.getBindingIdentifier(name) === node;\n  }\n\n  getBinding(name) {\n    let scope = this;\n    let previousPath;\n\n    do {\n      const binding = scope.getOwnBinding(name);\n\n      if (binding) {\n        var _previousPath;\n\n        if ((_previousPath = previousPath) != null && _previousPath.isPattern() && binding.kind !== \"param\" && binding.kind !== \"local\") {} else {\n          return binding;\n        }\n      } else if (!binding && name === \"arguments\" && scope.path.isFunction() && !scope.path.isArrowFunctionExpression()) {\n        break;\n      }\n\n      previousPath = scope.path;\n    } while (scope = scope.parent);\n  }\n\n  getOwnBinding(name) {\n    return this.bindings[name];\n  }\n\n  getBindingIdentifier(name) {\n    var _this$getBinding;\n\n    return (_this$getBinding = this.getBinding(name)) == null ? void 0 : _this$getBinding.identifier;\n  }\n\n  getOwnBindingIdentifier(name) {\n    const binding = this.bindings[name];\n    return binding == null ? void 0 : binding.identifier;\n  }\n\n  hasOwnBinding(name) {\n    return !!this.getOwnBinding(name);\n  }\n\n  hasBinding(name, noGlobals) {\n    if (!name) return false;\n    if (this.hasOwnBinding(name)) return true;\n    if (this.parentHasBinding(name, noGlobals)) return true;\n    if (this.hasUid(name)) return true;\n    if (!noGlobals && Scope.globals.includes(name)) return true;\n    if (!noGlobals && Scope.contextVariables.includes(name)) return true;\n    return false;\n  }\n\n  parentHasBinding(name, noGlobals) {\n    var _this$parent;\n\n    return (_this$parent = this.parent) == null ? void 0 : _this$parent.hasBinding(name, noGlobals);\n  }\n\n  moveBindingTo(name, scope) {\n    const info = this.getBinding(name);\n\n    if (info) {\n      info.scope.removeOwnBinding(name);\n      info.scope = scope;\n      scope.bindings[name] = info;\n    }\n  }\n\n  removeOwnBinding(name) {\n    delete this.bindings[name];\n  }\n\n  removeBinding(name) {\n    var _this$getBinding2;\n\n    (_this$getBinding2 = this.getBinding(name)) == null ? void 0 : _this$getBinding2.scope.removeOwnBinding(name);\n    let scope = this;\n\n    do {\n      if (scope.uids[name]) {\n        scope.uids[name] = false;\n      }\n    } while (scope = scope.parent);\n  }\n\n}\n\nexports.default = Scope;\nScope.globals = Object.keys(_globals.builtin);\nScope.contextVariables = [\"arguments\", \"undefined\", \"Infinity\", \"NaN\"];"]},"metadata":{},"sourceType":"script"}