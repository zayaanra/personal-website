{"ast":null,"code":"export default class MapperRegistry {\n  constructor(module) {\n    this.sortedMappers = [];\n    this.mappers = new Map();\n    this.updatedSinceLastExecute = false;\n    this._module = module;\n  }\n\n  startMapper(mapper) {\n    this.mappers.set(mapper.id, mapper);\n    this.updatedSinceLastExecute = true;\n    return mapper.id;\n  }\n\n  stopMapper(id) {\n    this.mappers.delete(id);\n    this.updatedSinceLastExecute = true;\n  }\n\n  execute() {\n    if (this.updatedSinceLastExecute) {\n      this.updateOrder();\n      this.updatedSinceLastExecute = false;\n    }\n\n    for (let i = 0, len = this.sortedMappers.length; i < len; ++i) {\n      const mapper = this.sortedMappers[i];\n\n      if (mapper.dirty) {\n        mapper.execute();\n      }\n    }\n  }\n\n  updateOrder() {\n    const nodes = [...this.mappers.values()].map(mapper => new Node(mapper));\n    const mappersById = {};\n    this.mappers.forEach(mapper => {\n      mappersById[mapper.id] = mapper;\n    }); // create a graph from array of nodes\n\n    for (let i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {\n      const node = nodes[i];\n\n      if (node.mapper.outputs.length === 0) {\n        continue;\n      }\n\n      for (let j = 0; j < nodesLen; ++j) {\n        const restNode = nodes[j];\n\n        if (i === j || restNode.mapper.inputs.length === 0) {\n          continue;\n        }\n\n        for (let outi = 0, outputsLen = node.mapper.outputs.length; outi < outputsLen; ++outi) {\n          for (let resti = 0, restLen = restNode.mapper.inputs.length; resti < restLen; ++resti) {\n            if (node.mapper.outputs[outi]._id === restNode.mapper.inputs[resti]._id) {\n              node.children.push(restNode);\n            }\n          }\n        }\n      }\n    }\n\n    const post = {};\n    let postCounter = 1;\n\n    const dfs = node => {\n      const index = nodes.indexOf(node);\n\n      if (index === -1) {\n        // this node has already been handled\n        return;\n      }\n\n      ++postCounter;\n      nodes.splice(index, 1);\n\n      if (node.children.length === 0 && nodes.length > 0) {\n        post[node.mapper.id] = postCounter++;\n        dfs(nodes[0]);\n        return;\n      }\n\n      for (let i = 0, len = node.children.length; i < len; ++i) {\n        dfs(node.children[i]);\n      }\n\n      post[node.mapper.id] = postCounter++;\n    };\n\n    while (nodes.length) dfs(nodes[0]);\n\n    const postArray = Object.keys(post).map(key => {\n      const num = parseInt(key);\n      return [num, post[num]];\n    });\n    postArray.sort((a, b) => {\n      return b[1] - a[1];\n    }); // clear sorted mappers\n\n    this.sortedMappers = [];\n\n    for (let i = 0, len = postArray.length; i < len; ++i) {\n      const [id] = postArray[i];\n      this.sortedMappers.push(mappersById[id]);\n    }\n  }\n\n  get needRunOnRender() {\n    return this.updatedSinceLastExecute;\n  }\n\n}\n\nclass Node {\n  constructor(mapper) {\n    let children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    this.mapper = mapper;\n    this.children = children;\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/react-native-reanimated/lib/reanimated2/js-reanimated/MapperRegistry.js"],"names":["MapperRegistry","constructor","module","sortedMappers","mappers","Map","updatedSinceLastExecute","_module","startMapper","mapper","set","id","stopMapper","delete","execute","updateOrder","i","len","length","dirty","nodes","values","map","Node","mappersById","forEach","nodesLen","node","outputs","j","restNode","inputs","outi","outputsLen","resti","restLen","_id","children","push","post","postCounter","dfs","index","indexOf","splice","postArray","Object","keys","key","num","parseInt","sort","a","b","needRunOnRender"],"mappings":"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","sourcesContent":["export default class MapperRegistry {\n    constructor(module) {\n        this.sortedMappers = [];\n        this.mappers = new Map();\n        this.updatedSinceLastExecute = false;\n        this._module = module;\n    }\n    startMapper(mapper) {\n        this.mappers.set(mapper.id, mapper);\n        this.updatedSinceLastExecute = true;\n        return mapper.id;\n    }\n    stopMapper(id) {\n        this.mappers.delete(id);\n        this.updatedSinceLastExecute = true;\n    }\n    execute() {\n        if (this.updatedSinceLastExecute) {\n            this.updateOrder();\n            this.updatedSinceLastExecute = false;\n        }\n        for (let i = 0, len = this.sortedMappers.length; i < len; ++i) {\n            const mapper = this.sortedMappers[i];\n            if (mapper.dirty) {\n                mapper.execute();\n            }\n        }\n    }\n    updateOrder() {\n        const nodes = [...this.mappers.values()].map((mapper) => new Node(mapper));\n        const mappersById = {};\n        this.mappers.forEach((mapper) => {\n            mappersById[mapper.id] = mapper;\n        });\n        // create a graph from array of nodes\n        for (let i = 0, nodesLen = nodes.length; i < nodesLen; ++i) {\n            const node = nodes[i];\n            if (node.mapper.outputs.length === 0) {\n                continue;\n            }\n            for (let j = 0; j < nodesLen; ++j) {\n                const restNode = nodes[j];\n                if (i === j || restNode.mapper.inputs.length === 0) {\n                    continue;\n                }\n                for (let outi = 0, outputsLen = node.mapper.outputs.length; outi < outputsLen; ++outi) {\n                    for (let resti = 0, restLen = restNode.mapper.inputs.length; resti < restLen; ++resti) {\n                        if (node.mapper.outputs[outi]._id ===\n                            restNode.mapper.inputs[resti]._id) {\n                            node.children.push(restNode);\n                        }\n                    }\n                }\n            }\n        }\n        const post = {};\n        let postCounter = 1;\n        const dfs = (node) => {\n            const index = nodes.indexOf(node);\n            if (index === -1) {\n                // this node has already been handled\n                return;\n            }\n            ++postCounter;\n            nodes.splice(index, 1);\n            if (node.children.length === 0 && nodes.length > 0) {\n                post[node.mapper.id] = postCounter++;\n                dfs(nodes[0]);\n                return;\n            }\n            for (let i = 0, len = node.children.length; i < len; ++i) {\n                dfs(node.children[i]);\n            }\n            post[node.mapper.id] = postCounter++;\n        };\n        while (nodes.length)\n            dfs(nodes[0]);\n        const postArray = Object.keys(post).map((key) => {\n            const num = parseInt(key);\n            return [num, post[num]];\n        });\n        postArray.sort((a, b) => {\n            return b[1] - a[1];\n        });\n        // clear sorted mappers\n        this.sortedMappers = [];\n        for (let i = 0, len = postArray.length; i < len; ++i) {\n            const [id] = postArray[i];\n            this.sortedMappers.push(mappersById[id]);\n        }\n    }\n    get needRunOnRender() {\n        return this.updatedSinceLastExecute;\n    }\n}\nclass Node {\n    constructor(mapper, children = []) {\n        this.mapper = mapper;\n        this.children = children;\n    }\n}\n"]},"metadata":{},"sourceType":"module"}