{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n      nodes.push(expressionStatement(cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist() {\n  let scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.scope;\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/traverse/lib/path/modification.js"],"names":["Object","defineProperty","exports","value","_containerInsert","_containerInsertAfter","_containerInsertBefore","_verifyNodeList","hoist","insertAfter","insertBefore","pushContainer","unshiftContainer","updateSiblingKeys","_cache","require","_hoister","_index","_t","arrowFunctionExpression","assertExpression","assignmentExpression","blockStatement","callExpression","cloneNode","expressionStatement","isExpression","nodes_","_assertUnremoved","nodes","parentPath","isExpressionStatement","isLabeledStatement","isExportNamedDeclaration","isExportDefaultDeclaration","isDeclaration","isNodeType","isJSXElement","isForStatement","key","node","push","replaceExpressionWithStatements","Array","isArray","container","isStatementOrBlock","shouldInsertCurrentNode","expression","replaceWith","Error","from","length","paths","splice","i","to","path","getSibling","context","queue","pushContext","contexts","_getQueueContexts","setScope","debug","maybeQueue","map","scope","isPattern","get","isMethod","computed","parent","temp","generateDeclaredUidIdentifier","unshift","fromIndex","incrementBy","msg","type","default","listKey","setContext","verifiedNodes","replaceWithMultiple","hoister","run"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports._containerInsert = _containerInsert;\nexports._containerInsertAfter = _containerInsertAfter;\nexports._containerInsertBefore = _containerInsertBefore;\nexports._verifyNodeList = _verifyNodeList;\nexports.hoist = hoist;\nexports.insertAfter = insertAfter;\nexports.insertBefore = insertBefore;\nexports.pushContainer = pushContainer;\nexports.unshiftContainer = unshiftContainer;\nexports.updateSiblingKeys = updateSiblingKeys;\n\nvar _cache = require(\"../cache\");\n\nvar _hoister = require(\"./lib/hoister\");\n\nvar _index = require(\"./index\");\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  arrowFunctionExpression,\n  assertExpression,\n  assignmentExpression,\n  blockStatement,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  isExpression\n} = _t;\n\nfunction insertBefore(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertBefore(nodes);\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) nodes.push(this.node);\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertBefore(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.unshiftContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction _containerInsert(from, nodes) {\n  this.updateSiblingKeys(from, nodes.length);\n  const paths = [];\n  this.container.splice(from, 0, ...nodes);\n\n  for (let i = 0; i < nodes.length; i++) {\n    const to = from + i;\n    const path = this.getSibling(to);\n    paths.push(path);\n\n    if (this.context && this.context.queue) {\n      path.pushContext(this.context);\n    }\n  }\n\n  const contexts = this._getQueueContexts();\n\n  for (const path of paths) {\n    path.setScope();\n    path.debug(\"Inserted.\");\n\n    for (const context of contexts) {\n      context.maybeQueue(path, true);\n    }\n  }\n\n  return paths;\n}\n\nfunction _containerInsertBefore(nodes) {\n  return this._containerInsert(this.key, nodes);\n}\n\nfunction _containerInsertAfter(nodes) {\n  return this._containerInsert(this.key + 1, nodes);\n}\n\nfunction insertAfter(nodes_) {\n  this._assertUnremoved();\n\n  const nodes = this._verifyNodeList(nodes_);\n\n  const {\n    parentPath\n  } = this;\n\n  if (parentPath.isExpressionStatement() || parentPath.isLabeledStatement() || parentPath.isExportNamedDeclaration() || parentPath.isExportDefaultDeclaration() && this.isDeclaration()) {\n    return parentPath.insertAfter(nodes.map(node => {\n      return isExpression(node) ? expressionStatement(node) : node;\n    }));\n  } else if (this.isNodeType(\"Expression\") && !this.isJSXElement() && !parentPath.isJSXElement() || parentPath.isForStatement() && this.key === \"init\") {\n    if (this.node) {\n      const node = this.node;\n      let {\n        scope\n      } = this;\n\n      if (scope.path.isPattern()) {\n        assertExpression(node);\n        this.replaceWith(callExpression(arrowFunctionExpression([], node), []));\n        this.get(\"callee.body\").insertAfter(nodes);\n        return [this];\n      }\n\n      if (parentPath.isMethod({\n        computed: true,\n        key: node\n      })) {\n        scope = scope.parent;\n      }\n\n      const temp = scope.generateDeclaredUidIdentifier();\n      nodes.unshift(expressionStatement(assignmentExpression(\"=\", cloneNode(temp), node)));\n      nodes.push(expressionStatement(cloneNode(temp)));\n    }\n\n    return this.replaceExpressionWithStatements(nodes);\n  } else if (Array.isArray(this.container)) {\n    return this._containerInsertAfter(nodes);\n  } else if (this.isStatementOrBlock()) {\n    const node = this.node;\n    const shouldInsertCurrentNode = node && (!this.isExpressionStatement() || node.expression != null);\n    this.replaceWith(blockStatement(shouldInsertCurrentNode ? [node] : []));\n    return this.pushContainer(\"body\", nodes);\n  } else {\n    throw new Error(\"We don't know what to do with this node type. \" + \"We were previously a Statement but we can't fit in here?\");\n  }\n}\n\nfunction updateSiblingKeys(fromIndex, incrementBy) {\n  if (!this.parent) return;\n\n  const paths = _cache.path.get(this.parent);\n\n  for (const [, path] of paths) {\n    if (path.key >= fromIndex) {\n      path.key += incrementBy;\n    }\n  }\n}\n\nfunction _verifyNodeList(nodes) {\n  if (!nodes) {\n    return [];\n  }\n\n  if (!Array.isArray(nodes)) {\n    nodes = [nodes];\n  }\n\n  for (let i = 0; i < nodes.length; i++) {\n    const node = nodes[i];\n    let msg;\n\n    if (!node) {\n      msg = \"has falsy node\";\n    } else if (typeof node !== \"object\") {\n      msg = \"contains a non-object node\";\n    } else if (!node.type) {\n      msg = \"without a type\";\n    } else if (node instanceof _index.default) {\n      msg = \"has a NodePath when it expected a raw object\";\n    }\n\n    if (msg) {\n      const type = Array.isArray(node) ? \"array\" : typeof node;\n      throw new Error(`Node list ${msg} with the index of ${i} and type of ${type}`);\n    }\n  }\n\n  return nodes;\n}\n\nfunction unshiftContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  nodes = this._verifyNodeList(nodes);\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: this.node[listKey],\n    listKey,\n    key: 0\n  }).setContext(this.context);\n\n  return path._containerInsertBefore(nodes);\n}\n\nfunction pushContainer(listKey, nodes) {\n  this._assertUnremoved();\n\n  const verifiedNodes = this._verifyNodeList(nodes);\n\n  const container = this.node[listKey];\n\n  const path = _index.default.get({\n    parentPath: this,\n    parent: this.node,\n    container: container,\n    listKey,\n    key: container.length\n  }).setContext(this.context);\n\n  return path.replaceWithMultiple(verifiedNodes);\n}\n\nfunction hoist(scope = this.scope) {\n  const hoister = new _hoister.default(this, scope);\n  return hoister.run();\n}"]},"metadata":{},"sourceType":"script"}