{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = require(\"./rewrite-this\");\n\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\n\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\n\nvar _getModuleName = require(\"./get-module-name\");\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, _ref) {\n  let {\n    loose,\n    exportName,\n    strict,\n    allowTopLevelThis,\n    strictMode,\n    noInterop,\n    importInterop = noInterop ? \"none\" : \"babel\",\n    lazy,\n    esNamespaceOnly,\n    constantReexports = loose,\n    enumerableModuleMeta = loose,\n    noIncompleteNsImportDetection\n  } = _ref;\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, _ref2 => {\n    let [exportName, importName] = _ref2;\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata) {\n  let enumerableModuleMeta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata) {\n  let constantReexports = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let noIncompleteNsImportDetection = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const initStatements = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  initStatements.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  const results = [];\n\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n\n    for (let i = 0, uninitializedExportNames = []; i < initStatements.length; i += chunkSize) {\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n\n  return results;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/helper-module-transforms/lib/index.js"],"names":["Object","defineProperty","exports","value","buildNamespaceInitStatements","ensureStatementsHoisted","enumerable","get","_getModuleName","default","_normalizeAndLoadMetadata","hasExports","_helperModuleImports","isModule","isSideEffectImport","rewriteModuleStatementsAndPrepareHeader","_rewriteThis","wrapInterop","_assert","require","_t","_template","_rewriteLiveReferences","booleanLiteral","callExpression","cloneNode","directive","directiveLiteral","expressionStatement","identifier","isIdentifier","memberExpression","stringLiteral","valueToNode","variableDeclaration","variableDeclarator","path","loose","exportName","strict","allowTopLevelThis","strictMode","noInterop","importInterop","lazy","esNamespaceOnly","constantReexports","enumerableModuleMeta","noIncompleteNsImportDetection","validateImportInteropOption","node","sourceType","meta","initializeReexports","hasStrict","directives","some","unshiftContainer","headers","push","buildESModuleHeader","nameList","buildExportNameListDeclaration","exportNameListName","name","statement","buildExportInitializationStatements","statements","forEach","header","_blockHoist","programPath","expr","type","hub","addHelper","helper","Error","metadata","sourceMetadata","srcNamespace","localName","importsNamespace","NAME","SOURCE","buildReexportsFromMeta","reexportNamespace","EXPORTS","NAMESPACE","reexportAll","buildNamespaceReexport","loc","ReexportTemplate","constant","constantComputed","spec","namespace","stringSpecifiers","Array","from","reexports","importName","NAMESPACE_IMPORT","interop","has","astNodes","EXPORT_NAME","VERIFY_NAME_LIST","EXPORTS_LIST","exportedVars","create","data","local","values","names","hasReexport","source","keys","length","scope","generateUidIdentifier","initStatements","kind","buildInitStatement","reexportsStatements","i","sort","a","b","results","initStatement","chunkSize","uninitializedExportNames","j","buildUndefinedNode","InitTemplate","computed","expression","exportNames","initExpr","reduce","acc","params","VALUE"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.buildNamespaceInitStatements = buildNamespaceInitStatements;\nexports.ensureStatementsHoisted = ensureStatementsHoisted;\nObject.defineProperty(exports, \"getModuleName\", {\n  enumerable: true,\n  get: function () {\n    return _getModuleName.default;\n  }\n});\nObject.defineProperty(exports, \"hasExports\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.hasExports;\n  }\n});\nObject.defineProperty(exports, \"isModule\", {\n  enumerable: true,\n  get: function () {\n    return _helperModuleImports.isModule;\n  }\n});\nObject.defineProperty(exports, \"isSideEffectImport\", {\n  enumerable: true,\n  get: function () {\n    return _normalizeAndLoadMetadata.isSideEffectImport;\n  }\n});\nexports.rewriteModuleStatementsAndPrepareHeader = rewriteModuleStatementsAndPrepareHeader;\nObject.defineProperty(exports, \"rewriteThis\", {\n  enumerable: true,\n  get: function () {\n    return _rewriteThis.default;\n  }\n});\nexports.wrapInterop = wrapInterop;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperModuleImports = require(\"@babel/helper-module-imports\");\n\nvar _rewriteThis = require(\"./rewrite-this\");\n\nvar _rewriteLiveReferences = require(\"./rewrite-live-references\");\n\nvar _normalizeAndLoadMetadata = require(\"./normalize-and-load-metadata\");\n\nvar _getModuleName = require(\"./get-module-name\");\n\nconst {\n  booleanLiteral,\n  callExpression,\n  cloneNode,\n  directive,\n  directiveLiteral,\n  expressionStatement,\n  identifier,\n  isIdentifier,\n  memberExpression,\n  stringLiteral,\n  valueToNode,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteModuleStatementsAndPrepareHeader(path, {\n  loose,\n  exportName,\n  strict,\n  allowTopLevelThis,\n  strictMode,\n  noInterop,\n  importInterop = noInterop ? \"none\" : \"babel\",\n  lazy,\n  esNamespaceOnly,\n  constantReexports = loose,\n  enumerableModuleMeta = loose,\n  noIncompleteNsImportDetection\n}) {\n  (0, _normalizeAndLoadMetadata.validateImportInteropOption)(importInterop);\n\n  _assert((0, _helperModuleImports.isModule)(path), \"Cannot process module statements in a script\");\n\n  path.node.sourceType = \"script\";\n  const meta = (0, _normalizeAndLoadMetadata.default)(path, exportName, {\n    importInterop,\n    initializeReexports: constantReexports,\n    lazy,\n    esNamespaceOnly\n  });\n\n  if (!allowTopLevelThis) {\n    (0, _rewriteThis.default)(path);\n  }\n\n  (0, _rewriteLiveReferences.default)(path, meta);\n\n  if (strictMode !== false) {\n    const hasStrict = path.node.directives.some(directive => {\n      return directive.value.value === \"use strict\";\n    });\n\n    if (!hasStrict) {\n      path.unshiftContainer(\"directives\", directive(directiveLiteral(\"use strict\")));\n    }\n  }\n\n  const headers = [];\n\n  if ((0, _normalizeAndLoadMetadata.hasExports)(meta) && !strict) {\n    headers.push(buildESModuleHeader(meta, enumerableModuleMeta));\n  }\n\n  const nameList = buildExportNameListDeclaration(path, meta);\n\n  if (nameList) {\n    meta.exportNameListName = nameList.name;\n    headers.push(nameList.statement);\n  }\n\n  headers.push(...buildExportInitializationStatements(path, meta, constantReexports, noIncompleteNsImportDetection));\n  return {\n    meta,\n    headers\n  };\n}\n\nfunction ensureStatementsHoisted(statements) {\n  statements.forEach(header => {\n    header._blockHoist = 3;\n  });\n}\n\nfunction wrapInterop(programPath, expr, type) {\n  if (type === \"none\") {\n    return null;\n  }\n\n  if (type === \"node-namespace\") {\n    return callExpression(programPath.hub.addHelper(\"interopRequireWildcard\"), [expr, booleanLiteral(true)]);\n  } else if (type === \"node-default\") {\n    return null;\n  }\n\n  let helper;\n\n  if (type === \"default\") {\n    helper = \"interopRequireDefault\";\n  } else if (type === \"namespace\") {\n    helper = \"interopRequireWildcard\";\n  } else {\n    throw new Error(`Unknown interop: ${type}`);\n  }\n\n  return callExpression(programPath.hub.addHelper(helper), [expr]);\n}\n\nfunction buildNamespaceInitStatements(metadata, sourceMetadata, constantReexports = false) {\n  const statements = [];\n  let srcNamespace = identifier(sourceMetadata.name);\n  if (sourceMetadata.lazy) srcNamespace = callExpression(srcNamespace, []);\n\n  for (const localName of sourceMetadata.importsNamespace) {\n    if (localName === sourceMetadata.name) continue;\n    statements.push(_template.default.statement`var NAME = SOURCE;`({\n      NAME: localName,\n      SOURCE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (constantReexports) {\n    statements.push(...buildReexportsFromMeta(metadata, sourceMetadata, true));\n  }\n\n  for (const exportName of sourceMetadata.reexportNamespace) {\n    statements.push((sourceMetadata.lazy ? _template.default.statement`\n            Object.defineProperty(EXPORTS, \"NAME\", {\n              enumerable: true,\n              get: function() {\n                return NAMESPACE;\n              }\n            });\n          ` : _template.default.statement`EXPORTS.NAME = NAMESPACE;`)({\n      EXPORTS: metadata.exportName,\n      NAME: exportName,\n      NAMESPACE: cloneNode(srcNamespace)\n    }));\n  }\n\n  if (sourceMetadata.reexportAll) {\n    const statement = buildNamespaceReexport(metadata, cloneNode(srcNamespace), constantReexports);\n    statement.loc = sourceMetadata.reexportAll.loc;\n    statements.push(statement);\n  }\n\n  return statements;\n}\n\nconst ReexportTemplate = {\n  constant: _template.default.statement`EXPORTS.EXPORT_NAME = NAMESPACE_IMPORT;`,\n  constantComputed: _template.default.statement`EXPORTS[\"EXPORT_NAME\"] = NAMESPACE_IMPORT;`,\n  spec: _template.default.statement`\n    Object.defineProperty(EXPORTS, \"EXPORT_NAME\", {\n      enumerable: true,\n      get: function() {\n        return NAMESPACE_IMPORT;\n      },\n    });\n    `\n};\n\nconst buildReexportsFromMeta = (meta, metadata, constantReexports) => {\n  const namespace = metadata.lazy ? callExpression(identifier(metadata.name), []) : identifier(metadata.name);\n  const {\n    stringSpecifiers\n  } = meta;\n  return Array.from(metadata.reexports, ([exportName, importName]) => {\n    let NAMESPACE_IMPORT = cloneNode(namespace);\n\n    if (importName === \"default\" && metadata.interop === \"node-default\") {} else if (stringSpecifiers.has(importName)) {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, stringLiteral(importName), true);\n    } else {\n      NAMESPACE_IMPORT = memberExpression(NAMESPACE_IMPORT, identifier(importName));\n    }\n\n    const astNodes = {\n      EXPORTS: meta.exportName,\n      EXPORT_NAME: exportName,\n      NAMESPACE_IMPORT\n    };\n\n    if (constantReexports || isIdentifier(NAMESPACE_IMPORT)) {\n      if (stringSpecifiers.has(exportName)) {\n        return ReexportTemplate.constantComputed(astNodes);\n      } else {\n        return ReexportTemplate.constant(astNodes);\n      }\n    } else {\n      return ReexportTemplate.spec(astNodes);\n    }\n  });\n};\n\nfunction buildESModuleHeader(metadata, enumerableModuleMeta = false) {\n  return (enumerableModuleMeta ? _template.default.statement`\n        EXPORTS.__esModule = true;\n      ` : _template.default.statement`\n        Object.defineProperty(EXPORTS, \"__esModule\", {\n          value: true,\n        });\n      `)({\n    EXPORTS: metadata.exportName\n  });\n}\n\nfunction buildNamespaceReexport(metadata, namespace, constantReexports) {\n  return (constantReexports ? _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          EXPORTS[key] = NAMESPACE[key];\n        });\n      ` : _template.default.statement`\n        Object.keys(NAMESPACE).forEach(function(key) {\n          if (key === \"default\" || key === \"__esModule\") return;\n          VERIFY_NAME_LIST;\n          if (key in EXPORTS && EXPORTS[key] === NAMESPACE[key]) return;\n\n          Object.defineProperty(EXPORTS, key, {\n            enumerable: true,\n            get: function() {\n              return NAMESPACE[key];\n            },\n          });\n        });\n    `)({\n    NAMESPACE: namespace,\n    EXPORTS: metadata.exportName,\n    VERIFY_NAME_LIST: metadata.exportNameListName ? (0, _template.default)`\n            if (Object.prototype.hasOwnProperty.call(EXPORTS_LIST, key)) return;\n          `({\n      EXPORTS_LIST: metadata.exportNameListName\n    }) : null\n  });\n}\n\nfunction buildExportNameListDeclaration(programPath, metadata) {\n  const exportedVars = Object.create(null);\n\n  for (const data of metadata.local.values()) {\n    for (const name of data.names) {\n      exportedVars[name] = true;\n    }\n  }\n\n  let hasReexport = false;\n\n  for (const data of metadata.source.values()) {\n    for (const exportName of data.reexports.keys()) {\n      exportedVars[exportName] = true;\n    }\n\n    for (const exportName of data.reexportNamespace) {\n      exportedVars[exportName] = true;\n    }\n\n    hasReexport = hasReexport || !!data.reexportAll;\n  }\n\n  if (!hasReexport || Object.keys(exportedVars).length === 0) return null;\n  const name = programPath.scope.generateUidIdentifier(\"exportNames\");\n  delete exportedVars.default;\n  return {\n    name: name.name,\n    statement: variableDeclaration(\"var\", [variableDeclarator(name, valueToNode(exportedVars))])\n  };\n}\n\nfunction buildExportInitializationStatements(programPath, metadata, constantReexports = false, noIncompleteNsImportDetection = false) {\n  const initStatements = [];\n\n  for (const [localName, data] of metadata.local) {\n    if (data.kind === \"import\") {} else if (data.kind === \"hoisted\") {\n      initStatements.push([data.names[0], buildInitStatement(metadata, data.names, identifier(localName))]);\n    } else if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.names) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  for (const data of metadata.source.values()) {\n    if (!constantReexports) {\n      const reexportsStatements = buildReexportsFromMeta(metadata, data, false);\n      const reexports = [...data.reexports.keys()];\n\n      for (let i = 0; i < reexportsStatements.length; i++) {\n        initStatements.push([reexports[i], reexportsStatements[i]]);\n      }\n    }\n\n    if (!noIncompleteNsImportDetection) {\n      for (const exportName of data.reexportNamespace) {\n        initStatements.push([exportName, null]);\n      }\n    }\n  }\n\n  initStatements.sort((a, b) => a[0] > b[0] ? 1 : -1);\n  const results = [];\n\n  if (noIncompleteNsImportDetection) {\n    for (const [, initStatement] of initStatements) {\n      results.push(initStatement);\n    }\n  } else {\n    const chunkSize = 100;\n\n    for (let i = 0, uninitializedExportNames = []; i < initStatements.length; i += chunkSize) {\n      for (let j = 0; j < chunkSize && i + j < initStatements.length; j++) {\n        const [exportName, initStatement] = initStatements[i + j];\n\n        if (initStatement !== null) {\n          if (uninitializedExportNames.length > 0) {\n            results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n            uninitializedExportNames = [];\n          }\n\n          results.push(initStatement);\n        } else {\n          uninitializedExportNames.push(exportName);\n        }\n      }\n\n      if (uninitializedExportNames.length > 0) {\n        results.push(buildInitStatement(metadata, uninitializedExportNames, programPath.scope.buildUndefinedNode()));\n      }\n    }\n  }\n\n  return results;\n}\n\nconst InitTemplate = {\n  computed: _template.default.expression`EXPORTS[\"NAME\"] = VALUE`,\n  default: _template.default.expression`EXPORTS.NAME = VALUE`\n};\n\nfunction buildInitStatement(metadata, exportNames, initExpr) {\n  const {\n    stringSpecifiers,\n    exportName: EXPORTS\n  } = metadata;\n  return expressionStatement(exportNames.reduce((acc, exportName) => {\n    const params = {\n      EXPORTS,\n      NAME: exportName,\n      VALUE: acc\n    };\n\n    if (stringSpecifiers.has(exportName)) {\n      return InitTemplate.computed(params);\n    } else {\n      return InitTemplate.default(params);\n    }\n  }, initExpr));\n}"]},"metadata":{},"sourceType":"script"}