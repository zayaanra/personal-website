{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath(_ref) {\n    let {\n      node,\n      parent\n    } = _ref;\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath(_ref2) {\n    let {\n      node,\n      parent\n    } = _ref2;\n\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath(_ref3) {\n    let {\n      node\n    } = _ref3;\n\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath(_ref4) {\n    let {\n      node\n    } = _ref4;\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/traverse/lib/path/lib/virtual-types.js"],"names":["Object","defineProperty","exports","value","Var","User","Statement","SpreadProperty","Scope","RestProperty","ReferencedMemberExpression","ReferencedIdentifier","Referenced","Pure","NumericLiteralTypeAnnotation","Generated","ForAwaitStatement","Flow","Expression","ExistentialTypeParam","BlockScoped","BindingIdentifier","_t","require","isBinding","isBlockScoped","isExportDeclaration","isExpression","isFlow","isForStatement","isForXStatement","isIdentifier","isImportDeclaration","isImportSpecifier","isJSXIdentifier","isJSXMemberExpression","isMemberExpression","isReferenced","isScope","isStatement","isVar","isVariableDeclaration","react","isCompatTag","types","checkPath","path","opts","node","parent","name","parentPath","grandparent","left","init","isReferencedIdentifier","loc","isUser","scope","isPure","importKind","exportKind","isObjectPattern","isObjectExpression","await"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Var = exports.User = exports.Statement = exports.SpreadProperty = exports.Scope = exports.RestProperty = exports.ReferencedMemberExpression = exports.ReferencedIdentifier = exports.Referenced = exports.Pure = exports.NumericLiteralTypeAnnotation = exports.Generated = exports.ForAwaitStatement = exports.Flow = exports.Expression = exports.ExistentialTypeParam = exports.BlockScoped = exports.BindingIdentifier = void 0;\n\nvar _t = require(\"@babel/types\");\n\nconst {\n  isBinding,\n  isBlockScoped,\n  isExportDeclaration,\n  isExpression,\n  isFlow,\n  isForStatement,\n  isForXStatement,\n  isIdentifier,\n  isImportDeclaration,\n  isImportSpecifier,\n  isJSXIdentifier,\n  isJSXMemberExpression,\n  isMemberExpression,\n  isReferenced,\n  isScope,\n  isStatement,\n  isVar,\n  isVariableDeclaration,\n  react\n} = _t;\nconst {\n  isCompatTag\n} = react;\nconst ReferencedIdentifier = {\n  types: [\"Identifier\", \"JSXIdentifier\"],\n\n  checkPath(path, opts) {\n    const {\n      node,\n      parent\n    } = path;\n\n    if (!isIdentifier(node, opts) && !isJSXMemberExpression(parent, opts)) {\n      if (isJSXIdentifier(node, opts)) {\n        if (isCompatTag(node.name)) return false;\n      } else {\n        return false;\n      }\n    }\n\n    return isReferenced(node, parent, path.parentPath.parent);\n  }\n\n};\nexports.ReferencedIdentifier = ReferencedIdentifier;\nconst ReferencedMemberExpression = {\n  types: [\"MemberExpression\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    return isMemberExpression(node) && isReferenced(node, parent);\n  }\n\n};\nexports.ReferencedMemberExpression = ReferencedMemberExpression;\nconst BindingIdentifier = {\n  types: [\"Identifier\"],\n\n  checkPath(path) {\n    const {\n      node,\n      parent\n    } = path;\n    const grandparent = path.parentPath.parent;\n    return isIdentifier(node) && isBinding(node, parent, grandparent);\n  }\n\n};\nexports.BindingIdentifier = BindingIdentifier;\nconst Statement = {\n  types: [\"Statement\"],\n\n  checkPath({\n    node,\n    parent\n  }) {\n    if (isStatement(node)) {\n      if (isVariableDeclaration(node)) {\n        if (isForXStatement(parent, {\n          left: node\n        })) return false;\n        if (isForStatement(parent, {\n          init: node\n        })) return false;\n      }\n\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Statement = Statement;\nconst Expression = {\n  types: [\"Expression\"],\n\n  checkPath(path) {\n    if (path.isIdentifier()) {\n      return path.isReferencedIdentifier();\n    } else {\n      return isExpression(path.node);\n    }\n  }\n\n};\nexports.Expression = Expression;\nconst Scope = {\n  types: [\"Scopable\", \"Pattern\"],\n\n  checkPath(path) {\n    return isScope(path.node, path.parent);\n  }\n\n};\nexports.Scope = Scope;\nconst Referenced = {\n  checkPath(path) {\n    return isReferenced(path.node, path.parent);\n  }\n\n};\nexports.Referenced = Referenced;\nconst BlockScoped = {\n  checkPath(path) {\n    return isBlockScoped(path.node);\n  }\n\n};\nexports.BlockScoped = BlockScoped;\nconst Var = {\n  types: [\"VariableDeclaration\"],\n\n  checkPath(path) {\n    return isVar(path.node);\n  }\n\n};\nexports.Var = Var;\nconst User = {\n  checkPath(path) {\n    return path.node && !!path.node.loc;\n  }\n\n};\nexports.User = User;\nconst Generated = {\n  checkPath(path) {\n    return !path.isUser();\n  }\n\n};\nexports.Generated = Generated;\nconst Pure = {\n  checkPath(path, opts) {\n    return path.scope.isPure(path.node, opts);\n  }\n\n};\nexports.Pure = Pure;\nconst Flow = {\n  types: [\"Flow\", \"ImportDeclaration\", \"ExportDeclaration\", \"ImportSpecifier\"],\n\n  checkPath({\n    node\n  }) {\n    if (isFlow(node)) {\n      return true;\n    } else if (isImportDeclaration(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else if (isExportDeclaration(node)) {\n      return node.exportKind === \"type\";\n    } else if (isImportSpecifier(node)) {\n      return node.importKind === \"type\" || node.importKind === \"typeof\";\n    } else {\n      return false;\n    }\n  }\n\n};\nexports.Flow = Flow;\nconst RestProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectPattern();\n  }\n\n};\nexports.RestProperty = RestProperty;\nconst SpreadProperty = {\n  types: [\"RestElement\"],\n\n  checkPath(path) {\n    return path.parentPath && path.parentPath.isObjectExpression();\n  }\n\n};\nexports.SpreadProperty = SpreadProperty;\nconst ExistentialTypeParam = {\n  types: [\"ExistsTypeAnnotation\"]\n};\nexports.ExistentialTypeParam = ExistentialTypeParam;\nconst NumericLiteralTypeAnnotation = {\n  types: [\"NumberLiteralTypeAnnotation\"]\n};\nexports.NumericLiteralTypeAnnotation = NumericLiteralTypeAnnotation;\nconst ForAwaitStatement = {\n  types: [\"ForOfStatement\"],\n\n  checkPath({\n    node\n  }) {\n    return node.await === true;\n  }\n\n};\nexports.ForAwaitStatement = ForAwaitStatement;"]},"metadata":{},"sourceType":"script"}