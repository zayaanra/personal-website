{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/traverse/lib/path/inference/inferers.js"],"names":["Object","defineProperty","exports","value","ArrayExpression","AssignmentExpression","BinaryExpression","BooleanLiteral","CallExpression","ConditionalExpression","ClassDeclaration","ClassExpression","FunctionDeclaration","ArrowFunctionExpression","FunctionExpression","Func","enumerable","get","_infererReference","default","LogicalExpression","NewExpression","NullLiteral","NumericLiteral","ObjectExpression","ParenthesizedExpression","RegExpLiteral","RestElement","SequenceExpression","StringLiteral","TaggedTemplateExpression","TemplateLiteral","TypeCastExpression","UnaryExpression","UpdateExpression","VariableDeclarator","_t","require","BOOLEAN_BINARY_OPERATORS","BOOLEAN_UNARY_OPERATORS","NUMBER_BINARY_OPERATORS","NUMBER_UNARY_OPERATORS","STRING_UNARY_OPERATORS","anyTypeAnnotation","arrayTypeAnnotation","booleanTypeAnnotation","buildMatchMemberExpression","createFlowUnionType","createTSUnionType","createUnionTypeAnnotation","genericTypeAnnotation","identifier","isTSTypeAnnotation","nullLiteralTypeAnnotation","numberTypeAnnotation","stringTypeAnnotation","tupleTypeAnnotation","unionTypeAnnotation","voidTypeAnnotation","_type","id","isIdentifier","init","type","getTypeAnnotation","isCallExpression","name","scope","hasBinding","node","typeAnnotation","validParent","callee","operator","indexOf","right","left","isBaseType","argumentTypes","pop","isArrayFrom","isObjectKeys","isObjectValues","isObjectEntries","resolveCall","resolve","isFunction","is","returnType"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ArrayExpression = ArrayExpression;\nexports.AssignmentExpression = AssignmentExpression;\nexports.BinaryExpression = BinaryExpression;\nexports.BooleanLiteral = BooleanLiteral;\nexports.CallExpression = CallExpression;\nexports.ConditionalExpression = ConditionalExpression;\nexports.ClassDeclaration = exports.ClassExpression = exports.FunctionDeclaration = exports.ArrowFunctionExpression = exports.FunctionExpression = Func;\nObject.defineProperty(exports, \"Identifier\", {\n  enumerable: true,\n  get: function () {\n    return _infererReference.default;\n  }\n});\nexports.LogicalExpression = LogicalExpression;\nexports.NewExpression = NewExpression;\nexports.NullLiteral = NullLiteral;\nexports.NumericLiteral = NumericLiteral;\nexports.ObjectExpression = ObjectExpression;\nexports.ParenthesizedExpression = ParenthesizedExpression;\nexports.RegExpLiteral = RegExpLiteral;\nexports.RestElement = RestElement;\nexports.SequenceExpression = SequenceExpression;\nexports.StringLiteral = StringLiteral;\nexports.TaggedTemplateExpression = TaggedTemplateExpression;\nexports.TemplateLiteral = TemplateLiteral;\nexports.TypeCastExpression = TypeCastExpression;\nexports.UnaryExpression = UnaryExpression;\nexports.UpdateExpression = UpdateExpression;\nexports.VariableDeclarator = VariableDeclarator;\n\nvar _t = require(\"@babel/types\");\n\nvar _infererReference = require(\"./inferer-reference\");\n\nconst {\n  BOOLEAN_BINARY_OPERATORS,\n  BOOLEAN_UNARY_OPERATORS,\n  NUMBER_BINARY_OPERATORS,\n  NUMBER_UNARY_OPERATORS,\n  STRING_UNARY_OPERATORS,\n  anyTypeAnnotation,\n  arrayTypeAnnotation,\n  booleanTypeAnnotation,\n  buildMatchMemberExpression,\n  createFlowUnionType,\n  createTSUnionType,\n  createUnionTypeAnnotation,\n  genericTypeAnnotation,\n  identifier,\n  isTSTypeAnnotation,\n  nullLiteralTypeAnnotation,\n  numberTypeAnnotation,\n  stringTypeAnnotation,\n  tupleTypeAnnotation,\n  unionTypeAnnotation,\n  voidTypeAnnotation\n} = _t;\n\nfunction VariableDeclarator() {\n  var _type;\n\n  const id = this.get(\"id\");\n  if (!id.isIdentifier()) return;\n  const init = this.get(\"init\");\n  let type = init.getTypeAnnotation();\n\n  if (((_type = type) == null ? void 0 : _type.type) === \"AnyTypeAnnotation\") {\n    if (init.isCallExpression() && init.get(\"callee\").isIdentifier({\n      name: \"Array\"\n    }) && !init.scope.hasBinding(\"Array\", true)) {\n      type = ArrayExpression();\n    }\n  }\n\n  return type;\n}\n\nfunction TypeCastExpression(node) {\n  return node.typeAnnotation;\n}\n\nTypeCastExpression.validParent = true;\n\nfunction NewExpression(node) {\n  if (this.get(\"callee\").isIdentifier()) {\n    return genericTypeAnnotation(node.callee);\n  }\n}\n\nfunction TemplateLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction UnaryExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"void\") {\n    return voidTypeAnnotation();\n  } else if (NUMBER_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (STRING_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return stringTypeAnnotation();\n  } else if (BOOLEAN_UNARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  }\n}\n\nfunction BinaryExpression(node) {\n  const operator = node.operator;\n\n  if (NUMBER_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return numberTypeAnnotation();\n  } else if (BOOLEAN_BINARY_OPERATORS.indexOf(operator) >= 0) {\n    return booleanTypeAnnotation();\n  } else if (operator === \"+\") {\n    const right = this.get(\"right\");\n    const left = this.get(\"left\");\n\n    if (left.isBaseType(\"number\") && right.isBaseType(\"number\")) {\n      return numberTypeAnnotation();\n    } else if (left.isBaseType(\"string\") || right.isBaseType(\"string\")) {\n      return stringTypeAnnotation();\n    }\n\n    return unionTypeAnnotation([stringTypeAnnotation(), numberTypeAnnotation()]);\n  }\n}\n\nfunction LogicalExpression() {\n  const argumentTypes = [this.get(\"left\").getTypeAnnotation(), this.get(\"right\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction ConditionalExpression() {\n  const argumentTypes = [this.get(\"consequent\").getTypeAnnotation(), this.get(\"alternate\").getTypeAnnotation()];\n\n  if (isTSTypeAnnotation(argumentTypes[0]) && createTSUnionType) {\n    return createTSUnionType(argumentTypes);\n  }\n\n  if (createFlowUnionType) {\n    return createFlowUnionType(argumentTypes);\n  }\n\n  return createUnionTypeAnnotation(argumentTypes);\n}\n\nfunction SequenceExpression() {\n  return this.get(\"expressions\").pop().getTypeAnnotation();\n}\n\nfunction ParenthesizedExpression() {\n  return this.get(\"expression\").getTypeAnnotation();\n}\n\nfunction AssignmentExpression() {\n  return this.get(\"right\").getTypeAnnotation();\n}\n\nfunction UpdateExpression(node) {\n  const operator = node.operator;\n\n  if (operator === \"++\" || operator === \"--\") {\n    return numberTypeAnnotation();\n  }\n}\n\nfunction StringLiteral() {\n  return stringTypeAnnotation();\n}\n\nfunction NumericLiteral() {\n  return numberTypeAnnotation();\n}\n\nfunction BooleanLiteral() {\n  return booleanTypeAnnotation();\n}\n\nfunction NullLiteral() {\n  return nullLiteralTypeAnnotation();\n}\n\nfunction RegExpLiteral() {\n  return genericTypeAnnotation(identifier(\"RegExp\"));\n}\n\nfunction ObjectExpression() {\n  return genericTypeAnnotation(identifier(\"Object\"));\n}\n\nfunction ArrayExpression() {\n  return genericTypeAnnotation(identifier(\"Array\"));\n}\n\nfunction RestElement() {\n  return ArrayExpression();\n}\n\nRestElement.validParent = true;\n\nfunction Func() {\n  return genericTypeAnnotation(identifier(\"Function\"));\n}\n\nconst isArrayFrom = buildMatchMemberExpression(\"Array.from\");\nconst isObjectKeys = buildMatchMemberExpression(\"Object.keys\");\nconst isObjectValues = buildMatchMemberExpression(\"Object.values\");\nconst isObjectEntries = buildMatchMemberExpression(\"Object.entries\");\n\nfunction CallExpression() {\n  const {\n    callee\n  } = this.node;\n\n  if (isObjectKeys(callee)) {\n    return arrayTypeAnnotation(stringTypeAnnotation());\n  } else if (isArrayFrom(callee) || isObjectValues(callee)) {\n    return arrayTypeAnnotation(anyTypeAnnotation());\n  } else if (isObjectEntries(callee)) {\n    return arrayTypeAnnotation(tupleTypeAnnotation([stringTypeAnnotation(), anyTypeAnnotation()]));\n  }\n\n  return resolveCall(this.get(\"callee\"));\n}\n\nfunction TaggedTemplateExpression() {\n  return resolveCall(this.get(\"tag\"));\n}\n\nfunction resolveCall(callee) {\n  callee = callee.resolve();\n\n  if (callee.isFunction()) {\n    if (callee.is(\"async\")) {\n      if (callee.is(\"generator\")) {\n        return genericTypeAnnotation(identifier(\"AsyncIterator\"));\n      } else {\n        return genericTypeAnnotation(identifier(\"Promise\"));\n      }\n    } else {\n      if (callee.node.returnType) {\n        return callee.node.returnType;\n      } else {}\n    }\n  }\n}"]},"metadata":{},"sourceType":"script"}