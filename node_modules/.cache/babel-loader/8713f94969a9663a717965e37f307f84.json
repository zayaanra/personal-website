{"ast":null,"code":"import { Easing } from '../Easing';\nimport { defineAnimation } from './util';\nexport function withTiming(toValue, userConfig, callback) {\n  'worklet';\n\n  return defineAnimation(toValue, () => {\n    'worklet';\n\n    const config = {\n      duration: 300,\n      easing: Easing.inOut(Easing.quad)\n    };\n\n    if (userConfig) {\n      Object.keys(userConfig).forEach(key => config[key] = userConfig[key]);\n    }\n\n    function timing(animation, now) {\n      const {\n        toValue,\n        startTime,\n        startValue\n      } = animation;\n      const runtime = now - startTime;\n\n      if (runtime >= config.duration) {\n        // reset startTime to avoid reusing finished animation config in `start` method\n        animation.startTime = 0;\n        animation.current = toValue;\n        return true;\n      }\n\n      const progress = animation.easing(runtime / config.duration);\n      animation.current = startValue + (toValue - startValue) * progress;\n      return false;\n    }\n\n    function onStart(animation, value, now, previousAnimation) {\n      if (previousAnimation && previousAnimation.type === 'timing' && previousAnimation.toValue === toValue && previousAnimation.startTime) {\n        // to maintain continuity of timing animations we check if we are starting\n        // new timing over the old one with the same parameters. If so, we want\n        // to copy animation timeline properties\n        animation.startTime = previousAnimation.startTime;\n        animation.startValue = previousAnimation.startValue;\n      } else {\n        animation.startTime = now;\n        animation.startValue = value;\n      }\n\n      animation.current = value;\n\n      if (typeof config.easing === 'object') {\n        animation.easing = config.easing.factory();\n      } else {\n        animation.easing = config.easing;\n      }\n    }\n\n    return {\n      type: 'timing',\n      onFrame: timing,\n      onStart: onStart,\n      progress: 0,\n      toValue,\n      startValue: 0,\n      startTime: 0,\n      easing: () => 0,\n      current: toValue,\n      callback\n    };\n  });\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/react-native-reanimated/lib/reanimated2/animation/timing.js"],"names":["Easing","defineAnimation","withTiming","toValue","userConfig","callback","config","duration","easing","inOut","quad","Object","keys","forEach","key","timing","animation","now","startTime","startValue","runtime","current","progress","onStart","value","previousAnimation","type","factory","onFrame"],"mappings":"AAAA,SAASA,MAAT,QAAuB,WAAvB;AACA,SAASC,eAAT,QAAgC,QAAhC;AACA,OAAO,SAASC,UAAT,CAAoBC,OAApB,EAA6BC,UAA7B,EAAyCC,QAAzC,EAAmD;AACtD;;AACA,SAAOJ,eAAe,CAACE,OAAD,EAAU,MAAM;AAClC;;AACA,UAAMG,MAAM,GAAG;AACXC,MAAAA,QAAQ,EAAE,GADC;AAEXC,MAAAA,MAAM,EAAER,MAAM,CAACS,KAAP,CAAaT,MAAM,CAACU,IAApB;AAFG,KAAf;;AAIA,QAAIN,UAAJ,EAAgB;AACZO,MAAAA,MAAM,CAACC,IAAP,CAAYR,UAAZ,EAAwBS,OAAxB,CAAiCC,GAAD,IAAUR,MAAM,CAACQ,GAAD,CAAN,GAAcV,UAAU,CAACU,GAAD,CAAlE;AACH;;AACD,aAASC,MAAT,CAAgBC,SAAhB,EAA2BC,GAA3B,EAAgC;AAC5B,YAAM;AAAEd,QAAAA,OAAF;AAAWe,QAAAA,SAAX;AAAsBC,QAAAA;AAAtB,UAAqCH,SAA3C;AACA,YAAMI,OAAO,GAAGH,GAAG,GAAGC,SAAtB;;AACA,UAAIE,OAAO,IAAId,MAAM,CAACC,QAAtB,EAAgC;AAC5B;AACAS,QAAAA,SAAS,CAACE,SAAV,GAAsB,CAAtB;AACAF,QAAAA,SAAS,CAACK,OAAV,GAAoBlB,OAApB;AACA,eAAO,IAAP;AACH;;AACD,YAAMmB,QAAQ,GAAGN,SAAS,CAACR,MAAV,CAAiBY,OAAO,GAAGd,MAAM,CAACC,QAAlC,CAAjB;AACAS,MAAAA,SAAS,CAACK,OAAV,GACIF,UAAU,GAAG,CAAChB,OAAO,GAAGgB,UAAX,IAAyBG,QAD1C;AAEA,aAAO,KAAP;AACH;;AACD,aAASC,OAAT,CAAiBP,SAAjB,EAA4BQ,KAA5B,EAAmCP,GAAnC,EAAwCQ,iBAAxC,EAA2D;AACvD,UAAIA,iBAAiB,IACjBA,iBAAiB,CAACC,IAAlB,KAA2B,QAD3B,IAEAD,iBAAiB,CAACtB,OAAlB,KAA8BA,OAF9B,IAGAsB,iBAAiB,CAACP,SAHtB,EAGiC;AAC7B;AACA;AACA;AACAF,QAAAA,SAAS,CAACE,SAAV,GAAsBO,iBAAiB,CAACP,SAAxC;AACAF,QAAAA,SAAS,CAACG,UAAV,GAAuBM,iBAAiB,CAACN,UAAzC;AACH,OATD,MAUK;AACDH,QAAAA,SAAS,CAACE,SAAV,GAAsBD,GAAtB;AACAD,QAAAA,SAAS,CAACG,UAAV,GAAuBK,KAAvB;AACH;;AACDR,MAAAA,SAAS,CAACK,OAAV,GAAoBG,KAApB;;AACA,UAAI,OAAOlB,MAAM,CAACE,MAAd,KAAyB,QAA7B,EAAuC;AACnCQ,QAAAA,SAAS,CAACR,MAAV,GAAmBF,MAAM,CAACE,MAAP,CAAcmB,OAAd,EAAnB;AACH,OAFD,MAGK;AACDX,QAAAA,SAAS,CAACR,MAAV,GAAmBF,MAAM,CAACE,MAA1B;AACH;AACJ;;AACD,WAAO;AACHkB,MAAAA,IAAI,EAAE,QADH;AAEHE,MAAAA,OAAO,EAAEb,MAFN;AAGHQ,MAAAA,OAAO,EAAEA,OAHN;AAIHD,MAAAA,QAAQ,EAAE,CAJP;AAKHnB,MAAAA,OALG;AAMHgB,MAAAA,UAAU,EAAE,CANT;AAOHD,MAAAA,SAAS,EAAE,CAPR;AAQHV,MAAAA,MAAM,EAAE,MAAM,CARX;AASHa,MAAAA,OAAO,EAAElB,OATN;AAUHE,MAAAA;AAVG,KAAP;AAYH,GA1DqB,CAAtB;AA2DH","sourcesContent":["import { Easing } from '../Easing';\nimport { defineAnimation } from './util';\nexport function withTiming(toValue, userConfig, callback) {\n    'worklet';\n    return defineAnimation(toValue, () => {\n        'worklet';\n        const config = {\n            duration: 300,\n            easing: Easing.inOut(Easing.quad),\n        };\n        if (userConfig) {\n            Object.keys(userConfig).forEach((key) => (config[key] = userConfig[key]));\n        }\n        function timing(animation, now) {\n            const { toValue, startTime, startValue } = animation;\n            const runtime = now - startTime;\n            if (runtime >= config.duration) {\n                // reset startTime to avoid reusing finished animation config in `start` method\n                animation.startTime = 0;\n                animation.current = toValue;\n                return true;\n            }\n            const progress = animation.easing(runtime / config.duration);\n            animation.current =\n                startValue + (toValue - startValue) * progress;\n            return false;\n        }\n        function onStart(animation, value, now, previousAnimation) {\n            if (previousAnimation &&\n                previousAnimation.type === 'timing' &&\n                previousAnimation.toValue === toValue &&\n                previousAnimation.startTime) {\n                // to maintain continuity of timing animations we check if we are starting\n                // new timing over the old one with the same parameters. If so, we want\n                // to copy animation timeline properties\n                animation.startTime = previousAnimation.startTime;\n                animation.startValue = previousAnimation.startValue;\n            }\n            else {\n                animation.startTime = now;\n                animation.startValue = value;\n            }\n            animation.current = value;\n            if (typeof config.easing === 'object') {\n                animation.easing = config.easing.factory();\n            }\n            else {\n                animation.easing = config.easing;\n            }\n        }\n        return {\n            type: 'timing',\n            onFrame: timing,\n            onStart: onStart,\n            progress: 0,\n            toValue,\n            startValue: 0,\n            startTime: 0,\n            easing: () => 0,\n            current: toValue,\n            callback,\n        };\n    });\n}\n"]},"metadata":{},"sourceType":"module"}