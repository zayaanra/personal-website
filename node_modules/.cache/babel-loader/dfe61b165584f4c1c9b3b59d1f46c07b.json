{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _fs() {\n  const data = require(\"fs\");\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  const data = require(\"@babel/types\");\n\n  _t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = require(\"./file/file\");\n\nvar _parser = require(\"../parser\");\n\nvar _cloneDeep = require(\"./util/clone-deep\");\n\nconst {\n  file,\n  traverseFast\n} = _t();\n\nconst debug = _debug()(\"babel:transform:file\");\n\nconst LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;\n\nfunction* normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    if (options.cloneInputAst) {\n      ast = (0, _cloneDeep.default)(ast);\n    }\n  } else {\n    ast = yield* (0, _parser.default)(pluginPasses, options, code);\n  }\n\n  let inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);\n\n          const inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]));\n\n          if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {\n            debug(\"skip merging input map > 1 MB\");\n          } else {\n            inputMap = _convertSourceMap().fromJSON(inputMapContent);\n          }\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new _file.default(options, {\n    code,\n    ast,\n    inputMap\n  });\n}\n\nconst INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(_ref => {\n      let {\n        value\n      } = _ref;\n\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  let lastComment = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);\n    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);\n    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);\n  });\n  return lastComment;\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/@babel/core/lib/transformation/normalize-file.js"],"names":["Object","defineProperty","exports","value","default","normalizeFile","_fs","data","require","_path","_debug","_t","_convertSourceMap","_file","_parser","_cloneDeep","file","traverseFast","debug","LARGE_INPUT_SOURCEMAP_THRESHOLD","pluginPasses","options","code","ast","type","Error","cloneInputAst","inputMap","inputSourceMap","fromObject","lastComment","extractComments","INLINE_SOURCEMAP_REGEX","fromComment","err","EXTERNAL_SOURCEMAP_REGEX","filename","match","exec","inputMapContent","readFileSync","resolve","dirname","length","fromJSON","extractCommentsFromList","regex","comments","filter","test","node","leadingComments","innerComments","trailingComments"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGAD,OAAO,CAACE,OAAR,GAAkBC,aAAlB;;AAEA,SAASC,GAAT,GAAe;AACb,QAAMC,IAAI,GAAGC,OAAO,CAAC,IAAD,CAApB;;AAEAF,EAAAA,GAAG,GAAG,YAAY;AAChB,WAAOC,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASE,KAAT,GAAiB;AACf,QAAMF,IAAI,GAAGC,OAAO,CAAC,MAAD,CAApB;;AAEAC,EAAAA,KAAK,GAAG,YAAY;AAClB,WAAOF,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASG,MAAT,GAAkB;AAChB,QAAMH,IAAI,GAAGC,OAAO,CAAC,OAAD,CAApB;;AAEAE,EAAAA,MAAM,GAAG,YAAY;AACnB,WAAOH,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASI,EAAT,GAAc;AACZ,QAAMJ,IAAI,GAAGC,OAAO,CAAC,cAAD,CAApB;;AAEAG,EAAAA,EAAE,GAAG,YAAY;AACf,WAAOJ,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,SAASK,iBAAT,GAA6B;AAC3B,QAAML,IAAI,GAAGC,OAAO,CAAC,oBAAD,CAApB;;AAEAI,EAAAA,iBAAiB,GAAG,YAAY;AAC9B,WAAOL,IAAP;AACD,GAFD;;AAIA,SAAOA,IAAP;AACD;;AAED,IAAIM,KAAK,GAAGL,OAAO,CAAC,aAAD,CAAnB;;AAEA,IAAIM,OAAO,GAAGN,OAAO,CAAC,WAAD,CAArB;;AAEA,IAAIO,UAAU,GAAGP,OAAO,CAAC,mBAAD,CAAxB;;AAEA,MAAM;AACJQ,EAAAA,IADI;AAEJC,EAAAA;AAFI,IAGFN,EAAE,EAHN;;AAKA,MAAMO,KAAK,GAAGR,MAAM,GAAG,sBAAH,CAApB;;AAEA,MAAMS,+BAA+B,GAAG,OAAxC;;AAEA,UAAUd,aAAV,CAAwBe,YAAxB,EAAsCC,OAAtC,EAA+CC,IAA/C,EAAqDC,GAArD,EAA0D;AACxDD,EAAAA,IAAI,GAAI,GAAEA,IAAI,IAAI,EAAG,EAArB;;AAEA,MAAIC,GAAJ,EAAS;AACP,QAAIA,GAAG,CAACC,IAAJ,KAAa,SAAjB,EAA4B;AAC1BD,MAAAA,GAAG,GAAGP,IAAI,CAACO,GAAD,EAAM,EAAN,EAAU,EAAV,CAAV;AACD,KAFD,MAEO,IAAIA,GAAG,CAACC,IAAJ,KAAa,MAAjB,EAAyB;AAC9B,YAAM,IAAIC,KAAJ,CAAU,yCAAV,CAAN;AACD;;AAED,QAAIJ,OAAO,CAACK,aAAZ,EAA2B;AACzBH,MAAAA,GAAG,GAAG,CAAC,GAAGR,UAAU,CAACX,OAAf,EAAwBmB,GAAxB,CAAN;AACD;AACF,GAVD,MAUO;AACLA,IAAAA,GAAG,GAAG,OAAO,CAAC,GAAGT,OAAO,CAACV,OAAZ,EAAqBgB,YAArB,EAAmCC,OAAnC,EAA4CC,IAA5C,CAAb;AACD;;AAED,MAAIK,QAAQ,GAAG,IAAf;;AAEA,MAAIN,OAAO,CAACO,cAAR,KAA2B,KAA/B,EAAsC;AACpC,QAAI,OAAOP,OAAO,CAACO,cAAf,KAAkC,QAAtC,EAAgD;AAC9CD,MAAAA,QAAQ,GAAGf,iBAAiB,GAAGiB,UAApB,CAA+BR,OAAO,CAACO,cAAvC,CAAX;AACD;;AAED,QAAI,CAACD,QAAL,EAAe;AACb,YAAMG,WAAW,GAAGC,eAAe,CAACC,sBAAD,EAAyBT,GAAzB,CAAnC;;AAEA,UAAIO,WAAJ,EAAiB;AACf,YAAI;AACFH,UAAAA,QAAQ,GAAGf,iBAAiB,GAAGqB,WAApB,CAAgCH,WAAhC,CAAX;AACD,SAFD,CAEE,OAAOI,GAAP,EAAY;AACZhB,UAAAA,KAAK,CAAC,2CAAD,EAA8CgB,GAA9C,CAAL;AACD;AACF;AACF;;AAED,QAAI,CAACP,QAAL,EAAe;AACb,YAAMG,WAAW,GAAGC,eAAe,CAACI,wBAAD,EAA2BZ,GAA3B,CAAnC;;AAEA,UAAI,OAAOF,OAAO,CAACe,QAAf,KAA4B,QAA5B,IAAwCN,WAA5C,EAAyD;AACvD,YAAI;AACF,gBAAMO,KAAK,GAAGF,wBAAwB,CAACG,IAAzB,CAA8BR,WAA9B,CAAd;;AAEA,gBAAMS,eAAe,GAAGjC,GAAG,GAAGkC,YAAN,CAAmB/B,KAAK,GAAGgC,OAAR,CAAgBhC,KAAK,GAAGiC,OAAR,CAAgBrB,OAAO,CAACe,QAAxB,CAAhB,EAAmDC,KAAK,CAAC,CAAD,CAAxD,CAAnB,CAAxB;;AAEA,cAAIE,eAAe,CAACI,MAAhB,GAAyBxB,+BAA7B,EAA8D;AAC5DD,YAAAA,KAAK,CAAC,+BAAD,CAAL;AACD,WAFD,MAEO;AACLS,YAAAA,QAAQ,GAAGf,iBAAiB,GAAGgC,QAApB,CAA6BL,eAA7B,CAAX;AACD;AACF,SAVD,CAUE,OAAOL,GAAP,EAAY;AACZhB,UAAAA,KAAK,CAAC,yCAAD,EAA4CgB,GAA5C,CAAL;AACD;AACF,OAdD,MAcO,IAAIJ,WAAJ,EAAiB;AACtBZ,QAAAA,KAAK,CAAC,6CAAD,CAAL;AACD;AACF;AACF;;AAED,SAAO,IAAIL,KAAK,CAACT,OAAV,CAAkBiB,OAAlB,EAA2B;AAChCC,IAAAA,IADgC;AAEhCC,IAAAA,GAFgC;AAGhCI,IAAAA;AAHgC,GAA3B,CAAP;AAKD;;AAED,MAAMK,sBAAsB,GAAG,8FAA/B;AACA,MAAMG,wBAAwB,GAAG,gDAAjC;;AAEA,SAASU,uBAAT,CAAiCC,KAAjC,EAAwCC,QAAxC,EAAkDjB,WAAlD,EAA+D;AAC7D,MAAIiB,QAAJ,EAAc;AACZA,IAAAA,QAAQ,GAAGA,QAAQ,CAACC,MAAT,CAAgB,QAErB;AAAA,UAFsB;AAC1B7C,QAAAA;AAD0B,OAEtB;;AACJ,UAAI2C,KAAK,CAACG,IAAN,CAAW9C,KAAX,CAAJ,EAAuB;AACrB2B,QAAAA,WAAW,GAAG3B,KAAd;AACA,eAAO,KAAP;AACD;;AAED,aAAO,IAAP;AACD,KATU,CAAX;AAUD;;AAED,SAAO,CAAC4C,QAAD,EAAWjB,WAAX,CAAP;AACD;;AAED,SAASC,eAAT,CAAyBe,KAAzB,EAAgCvB,GAAhC,EAAqC;AACnC,MAAIO,WAAW,GAAG,IAAlB;AACAb,EAAAA,YAAY,CAACM,GAAD,EAAM2B,IAAI,IAAI;AACxB,KAACA,IAAI,CAACC,eAAN,EAAuBrB,WAAvB,IAAsCe,uBAAuB,CAACC,KAAD,EAAQI,IAAI,CAACC,eAAb,EAA8BrB,WAA9B,CAA7D;AACA,KAACoB,IAAI,CAACE,aAAN,EAAqBtB,WAArB,IAAoCe,uBAAuB,CAACC,KAAD,EAAQI,IAAI,CAACE,aAAb,EAA4BtB,WAA5B,CAA3D;AACA,KAACoB,IAAI,CAACG,gBAAN,EAAwBvB,WAAxB,IAAuCe,uBAAuB,CAACC,KAAD,EAAQI,IAAI,CAACG,gBAAb,EAA+BvB,WAA/B,CAA9D;AACD,GAJW,CAAZ;AAKA,SAAOA,WAAP;AACD","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = normalizeFile;\n\nfunction _fs() {\n  const data = require(\"fs\");\n\n  _fs = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _path() {\n  const data = require(\"path\");\n\n  _path = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _debug() {\n  const data = require(\"debug\");\n\n  _debug = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _t() {\n  const data = require(\"@babel/types\");\n\n  _t = function () {\n    return data;\n  };\n\n  return data;\n}\n\nfunction _convertSourceMap() {\n  const data = require(\"convert-source-map\");\n\n  _convertSourceMap = function () {\n    return data;\n  };\n\n  return data;\n}\n\nvar _file = require(\"./file/file\");\n\nvar _parser = require(\"../parser\");\n\nvar _cloneDeep = require(\"./util/clone-deep\");\n\nconst {\n  file,\n  traverseFast\n} = _t();\n\nconst debug = _debug()(\"babel:transform:file\");\n\nconst LARGE_INPUT_SOURCEMAP_THRESHOLD = 1000000;\n\nfunction* normalizeFile(pluginPasses, options, code, ast) {\n  code = `${code || \"\"}`;\n\n  if (ast) {\n    if (ast.type === \"Program\") {\n      ast = file(ast, [], []);\n    } else if (ast.type !== \"File\") {\n      throw new Error(\"AST root must be a Program or File node\");\n    }\n\n    if (options.cloneInputAst) {\n      ast = (0, _cloneDeep.default)(ast);\n    }\n  } else {\n    ast = yield* (0, _parser.default)(pluginPasses, options, code);\n  }\n\n  let inputMap = null;\n\n  if (options.inputSourceMap !== false) {\n    if (typeof options.inputSourceMap === \"object\") {\n      inputMap = _convertSourceMap().fromObject(options.inputSourceMap);\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(INLINE_SOURCEMAP_REGEX, ast);\n\n      if (lastComment) {\n        try {\n          inputMap = _convertSourceMap().fromComment(lastComment);\n        } catch (err) {\n          debug(\"discarding unknown inline input sourcemap\", err);\n        }\n      }\n    }\n\n    if (!inputMap) {\n      const lastComment = extractComments(EXTERNAL_SOURCEMAP_REGEX, ast);\n\n      if (typeof options.filename === \"string\" && lastComment) {\n        try {\n          const match = EXTERNAL_SOURCEMAP_REGEX.exec(lastComment);\n\n          const inputMapContent = _fs().readFileSync(_path().resolve(_path().dirname(options.filename), match[1]));\n\n          if (inputMapContent.length > LARGE_INPUT_SOURCEMAP_THRESHOLD) {\n            debug(\"skip merging input map > 1 MB\");\n          } else {\n            inputMap = _convertSourceMap().fromJSON(inputMapContent);\n          }\n        } catch (err) {\n          debug(\"discarding unknown file input sourcemap\", err);\n        }\n      } else if (lastComment) {\n        debug(\"discarding un-loadable file input sourcemap\");\n      }\n    }\n  }\n\n  return new _file.default(options, {\n    code,\n    ast,\n    inputMap\n  });\n}\n\nconst INLINE_SOURCEMAP_REGEX = /^[@#]\\s+sourceMappingURL=data:(?:application|text)\\/json;(?:charset[:=]\\S+?;)?base64,(?:.*)$/;\nconst EXTERNAL_SOURCEMAP_REGEX = /^[@#][ \\t]+sourceMappingURL=([^\\s'\"`]+)[ \\t]*$/;\n\nfunction extractCommentsFromList(regex, comments, lastComment) {\n  if (comments) {\n    comments = comments.filter(({\n      value\n    }) => {\n      if (regex.test(value)) {\n        lastComment = value;\n        return false;\n      }\n\n      return true;\n    });\n  }\n\n  return [comments, lastComment];\n}\n\nfunction extractComments(regex, ast) {\n  let lastComment = null;\n  traverseFast(ast, node => {\n    [node.leadingComments, lastComment] = extractCommentsFromList(regex, node.leadingComments, lastComment);\n    [node.innerComments, lastComment] = extractCommentsFromList(regex, node.innerComments, lastComment);\n    [node.trailingComments, lastComment] = extractCommentsFromList(regex, node.trailingComments, lastComment);\n  });\n  return lastComment;\n}"]},"metadata":{},"sourceType":"script"}