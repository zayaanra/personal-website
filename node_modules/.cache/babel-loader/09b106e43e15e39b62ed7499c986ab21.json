{"ast":null,"code":"import { Easing } from '../../Easing';\nimport { withDelay, withSequence, withTiming } from '../../animation';\nexport class Keyframe {\n  /*\n    Keyframe definition should be passed in the constructor as the map\n    which keys are between range 0 - 100 (%) and correspond to the point in the animation progress.\n  */\n  constructor(definitions) {\n    this.build = () => {\n      const delay = this.delayV;\n      const delayFunction = this.getDelayFunction();\n      const {\n        keyframes,\n        initialValues\n      } = this.parseDefinitions();\n      const callback = this.callbackV;\n      return _targetValues => {\n        'worklet';\n\n        const animations = {};\n        /*\n              For each style property, an animations sequence is created that corresponds with its key points.\n              Transform style properties require special handling because of their nested structure.\n        */\n\n        const addAnimation = key => {\n          var _a;\n\n          const keyframePoints = keyframes[key]; // in case if property was only passed as initial value\n\n          if (keyframePoints.length === 0) return;\n          const animation = delayFunction(delay, keyframePoints.length === 1 ? withTiming(keyframePoints[0].value, {\n            duration: keyframePoints[0].duration,\n            easing: keyframePoints[0].easing ? keyframePoints[0].easing : Easing.linear\n          }) : withSequence.apply(this, keyframePoints.map(keyframePoint => withTiming(keyframePoint.value, {\n            duration: keyframePoint.duration,\n            easing: keyframePoint.easing ? keyframePoint.easing : Easing.linear\n          }))));\n\n          if (key.includes('transform')) {\n            if (!('transform' in animations)) {\n              animations.transform = [];\n            }\n\n            (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push({\n              [key.split(':')[1]]: animation\n            });\n          } else {\n            animations[key] = animation;\n          }\n        };\n\n        Object.keys(initialValues).forEach(key => {\n          if (key.includes('transform')) {\n            initialValues[key].forEach((transformProp, index) => {\n              Object.keys(transformProp).forEach(transformPropKey => {\n                addAnimation(index.toString() + '_transform:' + transformPropKey);\n              });\n            });\n          } else {\n            addAnimation(key);\n          }\n        });\n        return {\n          animations: animations,\n          initialValues: initialValues,\n          callback: callback\n        };\n      };\n    };\n\n    this.definitions = definitions;\n  }\n\n  parseDefinitions() {\n    /*\n        Each style property contain an array with all their key points:\n        value, duration of transition to that value, and optional easing function (defaults to Linear)\n    */\n    const parsedKeyframes = {};\n    /*\n      Parsing keyframes 'from' and 'to'.\n    */\n\n    if (this.definitions.from) {\n      if (this.definitions['0']) {\n        throw Error(\"You cannot provide both keyframe 0 and 'from' as they both specified initial values\");\n      }\n\n      this.definitions['0'] = this.definitions.from;\n      delete this.definitions.from;\n    }\n\n    if (this.definitions.to) {\n      if (this.definitions['100']) {\n        throw Error(\"You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.\");\n      }\n\n      this.definitions['100'] = this.definitions.to;\n      delete this.definitions.to;\n    }\n    /*\n       One of the assumptions is that keyframe  0 is required to properly set initial values.\n       Every other keyframe should contain properties from the set provided as initial values.\n    */\n\n\n    if (!this.definitions['0']) {\n      throw Error(\"Please provide 0, or 'from' keyframe with initial state of your object.\");\n    }\n\n    const initialValues = this.definitions['0'];\n    /*\n      Initialize parsedKeyframes for properties provided in initial keyframe\n    */\n\n    Object.keys(initialValues).forEach(styleProp => {\n      var _a;\n\n      if (styleProp === 'transform') {\n        (_a = initialValues[styleProp]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index) => {\n          Object.keys(transformStyle).forEach(transformProp => {\n            parsedKeyframes[index.toString() + '_transform:' + transformProp] = [];\n          });\n        });\n      } else {\n        parsedKeyframes[styleProp] = [];\n      }\n    });\n    const duration = this.durationV ? this.durationV : 500;\n    const animationKeyPoints = Array.from(Object.keys(this.definitions));\n\n    const getAnimationDuration = (key, currentKeyPoint) => {\n      const maxDuration = currentKeyPoint / 100 * duration;\n      const currentDuration = parsedKeyframes[key].reduce((acc, value) => acc + value.duration, 0);\n      return maxDuration - currentDuration;\n    };\n    /*\n       Other keyframes can't contain properties that were not specified in initial keyframe.\n    */\n\n\n    const addKeyPoint = _ref => {\n      let {\n        key,\n        value,\n        currentKeyPoint,\n        easing\n      } = _ref;\n\n      if (!(key in parsedKeyframes)) {\n        throw Error(\"Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')\");\n      }\n\n      parsedKeyframes[key].push({\n        duration: getAnimationDuration(key, currentKeyPoint),\n        value: value,\n        easing: easing\n      });\n    };\n\n    animationKeyPoints.filter(value => parseInt(value) !== 0).sort((a, b) => parseInt(a) - parseInt(b)).forEach(keyPoint => {\n      if (parseInt(keyPoint) < 0 || parseInt(keyPoint) > 100) {\n        throw Error('Keyframe should be in between range 0 - 100.');\n      }\n\n      const keyframe = this.definitions[keyPoint];\n      const easing = keyframe.easing;\n      delete keyframe.easing;\n\n      const addKeyPointWith = (key, value) => addKeyPoint({\n        key,\n        value,\n        currentKeyPoint: parseInt(keyPoint),\n        easing\n      });\n\n      Object.keys(keyframe).forEach(key => {\n        var _a;\n\n        if (key === 'transform') {\n          (_a = keyframe[key]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index) => {\n            Object.keys(transformStyle).forEach(transformProp => {\n              addKeyPointWith(index.toString() + '_transform:' + transformProp, transformStyle[transformProp]);\n            });\n          });\n        } else {\n          addKeyPointWith(key, keyframe[key]);\n        }\n      });\n    });\n    return {\n      initialValues: initialValues,\n      keyframes: parsedKeyframes\n    };\n  }\n\n  duration(durationMs) {\n    this.durationV = durationMs;\n    return this;\n  }\n\n  delay(delayMs) {\n    this.delayV = delayMs;\n    return this;\n  }\n\n  withCallback(callback) {\n    this.callbackV = callback;\n    return this;\n  }\n\n  getDelayFunction() {\n    const delay = this.delayV;\n    return delay ? withDelay : (_, animation) => {\n      'worklet';\n\n      return animation;\n    };\n  }\n\n}","map":{"version":3,"sources":["C:/Users/rahma/Desktop/Projects/Python/website/personal-website/frontend/app/node_modules/react-native-reanimated/lib/reanimated2/layoutReanimation/animationBuilder/Keyframe.js"],"names":["Easing","withDelay","withSequence","withTiming","Keyframe","constructor","definitions","build","delay","delayV","delayFunction","getDelayFunction","keyframes","initialValues","parseDefinitions","callback","callbackV","_targetValues","animations","addAnimation","key","_a","keyframePoints","length","animation","value","duration","easing","linear","apply","map","keyframePoint","includes","transform","push","split","Object","keys","forEach","transformProp","index","transformPropKey","toString","parsedKeyframes","from","Error","to","styleProp","transformStyle","durationV","animationKeyPoints","Array","getAnimationDuration","currentKeyPoint","maxDuration","currentDuration","reduce","acc","addKeyPoint","filter","parseInt","sort","a","b","keyPoint","keyframe","addKeyPointWith","durationMs","delayMs","withCallback","_"],"mappings":"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","sourcesContent":["import { Easing } from '../../Easing';\nimport { withDelay, withSequence, withTiming } from '../../animation';\nexport class Keyframe {\n    /*\n      Keyframe definition should be passed in the constructor as the map\n      which keys are between range 0 - 100 (%) and correspond to the point in the animation progress.\n    */\n    constructor(definitions) {\n        this.build = () => {\n            const delay = this.delayV;\n            const delayFunction = this.getDelayFunction();\n            const { keyframes, initialValues } = this.parseDefinitions();\n            const callback = this.callbackV;\n            return (_targetValues) => {\n                'worklet';\n                const animations = {};\n                /*\n                      For each style property, an animations sequence is created that corresponds with its key points.\n                      Transform style properties require special handling because of their nested structure.\n                */\n                const addAnimation = (key) => {\n                    var _a;\n                    const keyframePoints = keyframes[key];\n                    // in case if property was only passed as initial value\n                    if (keyframePoints.length === 0)\n                        return;\n                    const animation = delayFunction(delay, keyframePoints.length === 1\n                        ? withTiming(keyframePoints[0].value, {\n                            duration: keyframePoints[0].duration,\n                            easing: keyframePoints[0].easing\n                                ? keyframePoints[0].easing\n                                : Easing.linear,\n                        })\n                        : withSequence.apply(this, keyframePoints.map((keyframePoint) => withTiming(keyframePoint.value, {\n                            duration: keyframePoint.duration,\n                            easing: keyframePoint.easing\n                                ? keyframePoint.easing\n                                : Easing.linear,\n                        }))));\n                    if (key.includes('transform')) {\n                        if (!('transform' in animations)) {\n                            animations.transform = [];\n                        }\n                        (_a = animations.transform) === null || _a === void 0 ? void 0 : _a.push({\n                            [key.split(':')[1]]: animation,\n                        });\n                    }\n                    else {\n                        animations[key] = animation;\n                    }\n                };\n                Object.keys(initialValues).forEach((key) => {\n                    if (key.includes('transform')) {\n                        initialValues[key].forEach((transformProp, index) => {\n                            Object.keys(transformProp).forEach((transformPropKey) => {\n                                addAnimation(index.toString() + '_transform:' + transformPropKey);\n                            });\n                        });\n                    }\n                    else {\n                        addAnimation(key);\n                    }\n                });\n                return {\n                    animations: animations,\n                    initialValues: initialValues,\n                    callback: callback,\n                };\n            };\n        };\n        this.definitions = definitions;\n    }\n    parseDefinitions() {\n        /*\n            Each style property contain an array with all their key points:\n            value, duration of transition to that value, and optional easing function (defaults to Linear)\n        */\n        const parsedKeyframes = {};\n        /*\n          Parsing keyframes 'from' and 'to'.\n        */\n        if (this.definitions.from) {\n            if (this.definitions['0']) {\n                throw Error(\"You cannot provide both keyframe 0 and 'from' as they both specified initial values\");\n            }\n            this.definitions['0'] = this.definitions.from;\n            delete this.definitions.from;\n        }\n        if (this.definitions.to) {\n            if (this.definitions['100']) {\n                throw Error(\"You cannot provide both keyframe 100 and 'to' as they both specified values at the end of the animation.\");\n            }\n            this.definitions['100'] = this.definitions.to;\n            delete this.definitions.to;\n        }\n        /*\n           One of the assumptions is that keyframe  0 is required to properly set initial values.\n           Every other keyframe should contain properties from the set provided as initial values.\n        */\n        if (!this.definitions['0']) {\n            throw Error(\"Please provide 0, or 'from' keyframe with initial state of your object.\");\n        }\n        const initialValues = this.definitions['0'];\n        /*\n          Initialize parsedKeyframes for properties provided in initial keyframe\n        */\n        Object.keys(initialValues).forEach((styleProp) => {\n            var _a;\n            if (styleProp === 'transform') {\n                (_a = initialValues[styleProp]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index) => {\n                    Object.keys(transformStyle).forEach((transformProp) => {\n                        parsedKeyframes[index.toString() + '_transform:' + transformProp] = [];\n                    });\n                });\n            }\n            else {\n                parsedKeyframes[styleProp] = [];\n            }\n        });\n        const duration = this.durationV ? this.durationV : 500;\n        const animationKeyPoints = Array.from(Object.keys(this.definitions));\n        const getAnimationDuration = (key, currentKeyPoint) => {\n            const maxDuration = (currentKeyPoint / 100) * duration;\n            const currentDuration = parsedKeyframes[key].reduce((acc, value) => acc + value.duration, 0);\n            return maxDuration - currentDuration;\n        };\n        /*\n           Other keyframes can't contain properties that were not specified in initial keyframe.\n        */\n        const addKeyPoint = ({ key, value, currentKeyPoint, easing, }) => {\n            if (!(key in parsedKeyframes)) {\n                throw Error(\"Keyframe can contain only that set of properties that were provide with initial values (keyframe 0 or 'from')\");\n            }\n            parsedKeyframes[key].push({\n                duration: getAnimationDuration(key, currentKeyPoint),\n                value: value,\n                easing: easing,\n            });\n        };\n        animationKeyPoints\n            .filter((value) => parseInt(value) !== 0)\n            .sort((a, b) => parseInt(a) - parseInt(b))\n            .forEach((keyPoint) => {\n            if (parseInt(keyPoint) < 0 || parseInt(keyPoint) > 100) {\n                throw Error('Keyframe should be in between range 0 - 100.');\n            }\n            const keyframe = this.definitions[keyPoint];\n            const easing = keyframe.easing;\n            delete keyframe.easing;\n            const addKeyPointWith = (key, value) => addKeyPoint({\n                key,\n                value,\n                currentKeyPoint: parseInt(keyPoint),\n                easing,\n            });\n            Object.keys(keyframe).forEach((key) => {\n                var _a;\n                if (key === 'transform') {\n                    (_a = keyframe[key]) === null || _a === void 0 ? void 0 : _a.forEach((transformStyle, index) => {\n                        Object.keys(transformStyle).forEach((transformProp) => {\n                            addKeyPointWith(index.toString() + '_transform:' + transformProp, transformStyle[transformProp]);\n                        });\n                    });\n                }\n                else {\n                    addKeyPointWith(key, keyframe[key]);\n                }\n            });\n        });\n        return { initialValues: initialValues, keyframes: parsedKeyframes };\n    }\n    duration(durationMs) {\n        this.durationV = durationMs;\n        return this;\n    }\n    delay(delayMs) {\n        this.delayV = delayMs;\n        return this;\n    }\n    withCallback(callback) {\n        this.callbackV = callback;\n        return this;\n    }\n    getDelayFunction() {\n        const delay = this.delayV;\n        return delay\n            ? withDelay\n            : (_, animation) => {\n                'worklet';\n                return animation;\n            };\n    }\n}\n"]},"metadata":{},"sourceType":"module"}